(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('deep-diff')) :
    typeof define === 'function' && define.amd ? define(['deep-diff'], factory) :
    (global = global || self, global.DataGrid = factory(global.DeepDiff));
}(this, function (DeepDiff) { 'use strict';

    function noop() { }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.data !== data)
            text.data = data;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function add_resize_listener(element, fn) {
        if (getComputedStyle(element).position === 'static') {
            element.style.position = 'relative';
        }
        const object = document.createElement('object');
        object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');
        object.type = 'text/html';
        object.tabIndex = -1;
        let win;
        object.onload = () => {
            win = object.contentDocument.defaultView;
            win.addEventListener('resize', fn);
        };
        if (/Trident/.test(navigator.userAgent)) {
            element.appendChild(object);
            object.data = 'about:blank';
        }
        else {
            object.data = 'about:blank';
            element.appendChild(object);
        }
        return {
            cancel: () => {
                win && win.removeEventListener && win.removeEventListener('resize', fn);
                element.removeChild(object);
            }
        };
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function createEventDispatcher() {
        const component = current_component;
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function flush() {
        const seen_callbacks = new Set();
        do {
            // first, call beforeUpdate functions
            // and update components
            while (dirty_components.length) {
                const component = dirty_components.shift();
                set_current_component(component);
                update(component.$$);
            }
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    callback();
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
    }
    function update($$) {
        if ($$.fragment) {
            $$.update($$.dirty);
            run_all($$.before_update);
            $$.fragment.p($$.dirty, $$.ctx);
            $$.dirty = null;
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined' ? window : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(changed, child_ctx);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        if (component.$$.fragment) {
            run_all(component.$$.on_destroy);
            component.$$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            component.$$.on_destroy = component.$$.fragment = null;
            component.$$.ctx = {};
        }
    }
    function make_dirty(component, key) {
        if (!component.$$.dirty) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty = blank_object();
        }
        component.$$.dirty[key] = true;
    }
    function init(component, options, instance, create_fragment, not_equal, prop_names) {
        const parent_component = current_component;
        set_current_component(component);
        const props = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props: prop_names,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty: null
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, props, (key, ret, value = ret) => {
                if ($$.ctx && not_equal($$.ctx[key], $$.ctx[key] = value)) {
                    if ($$.bound[key])
                        $$.bound[key](value);
                    if (ready)
                        make_dirty(component, key);
                }
                return ret;
            })
            : props;
        $$.update();
        ready = true;
        run_all($$.before_update);
        $$.fragment = create_fragment($$.ctx);
        if (options.target) {
            if (options.hydrate) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment.l(children(options.target));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }

    const applyChange = DeepDiff.applyChange;
    const diff = DeepDiff.diff;
    /**
     * Edit history tracker for a javascript object using deep-diff to generate and apply patches
     */
    class EditHistory {
      /**
       * Instantiates an instance of EditHistory
       * @param {Object} obj The object or array to track
       */
      constructor(obj) {
        this.obj = JSON.parse(JSON.stringify(obj));

        // initialize arrays for forwards and backwards patches
        this.forward = [];
        this.backward = [];
      }

      /**
       * Clears all forward and backward patches
       */
      clear() {
        this.forward = [];
        this.backward = [];
      }

      /**
       * Records a change to an object
       * @param {Object} newObj The new object
       */
      recordChange(newObj) {
        const patch = {
          redo: diff(this.obj, newObj),
          undo: diff(newObj, this.obj)
        };

        if (!patch.redo || !patch.undo) {
          console.warn("Objects could not be diffed");
        } else {
          this.obj = JSON.parse(JSON.stringify(newObj));
          this.backward.push(patch);
        }
      }

      /**
       * Applies the most recent undo patch and returns the new object
       * @returns {Object} The tracked object
       */
      undo() {
        if (this.backward.length === 0) {
          return null;
        }

        // grab the most recent backwards patch
        const patch = this.backward.pop();

        // applyChange doesn't accept arrays, only its members
        patch.undo.forEach(x => applyChange(this.obj, x));

        // put the patch into the forward queue
        this.forward.push(patch);

        return JSON.parse(JSON.stringify(this.obj));
      }

      /**
       * Applies the most recent redo patch and returns the new object
       * @returns {Object} The tracked object
       */
      redo() {
        if (this.forward.length === 0) {
          return null;
        }

        // grab the most recent forwards patch
        const patch = this.forward.pop();

        // applyChange doesn't accept arrays, only its members
        patch.redo.forEach(x => applyChange(this.obj, x));

        // put the patch into the backward queue
        this.backward.push(patch);

        return JSON.parse(JSON.stringify(this.obj));
      }

      /**
       * Applies all the undo patches in the queue and returns the new object
       * @returns {Object} The tracked object
       */
      undoAll() {
        while (this.backward.length > 0) {
          this.undo();
        }

        return this.obj;
      }

      /**
       * Applies all the redo patches in the queue and returns the new object
       * @returns {Object} The tracked object
       */
      redoAll() {
        while (this.forward.length > 0) {
          this.redo();
        }

        return this.obj;
      }
    }

    /* src\index.svelte generated by Svelte v3.12.1 */
    const { document: document_1, window: window_1 } = globals;

    function add_css() {
    	var style = element("style");
    	style.id = 'svelte-b58rik-style';
    	style.textContent = ".row-action-line.svelte-b58rik{position:absolute;left:0;width:100%;height:4px;z-index:6;background:#aaa}.row-affix-marker.svelte-b58rik{display:none;position:absolute;left:0;height:4px;z-index:6;background:white;border-top:1px solid #999;border-bottom:1px solid #999;cursor:ns-resize}.column-affix-marker.svelte-b58rik{position:absolute;top:0;width:4px;z-index:5;background:white;border-left:1px solid #999;border-right:1px solid #999;cursor:ew-resize;transform:translateX(-50%)}.resizing.svelte-b58rik .svelte-b58rik{user-select:none}.resizing.svelte-b58rik .grid-inner.svelte-b58rik{overflow-y:hidden}.resizing.svelte-b58rik .grid-space.svelte-b58rik{pointer-events:all}.grid-cell.svelte-b58rik>.svelte-b58rik{height:100%}.cell-default.svelte-b58rik{padding:0 5px;background:white;overflow:hidden;text-overflow:ellipsis}.data-grid-wrapper.svelte-b58rik{position:relative;width:100%;height:100%}.column-action-line.svelte-b58rik{position:absolute;top:0;bottom:17px;z-index:3;width:4px;background:#aaa;cursor:ew-resize}.grid-cell-size-capture.svelte-b58rik{position:absolute;top:0;bottom:0;z-index:5;background:transparent;cursor:ew-resize;pointer-events:all}.grid-inner.svelte-b58rik{overflow:auto}.grid-space.svelte-b58rik{position:absolute;top:0;left:0;background:transparent;pointer-events:none;z-index:3}.grid-headers.svelte-b58rik{position:absolute;overflow:hidden;max-width:100%;width:100%;top:0;left:0;border-bottom:2px solid black}.grid-headers.svelte-b58rik .grid-cell.svelte-b58rik{text-align:center;font-weight:bold;cursor:pointer}.grid-headers.svelte-b58rik .cell-default.svelte-b58rik:hover{background:#eee}.grid-header-row.svelte-b58rik{position:absolute;overflow:hidden;top:0}.grid-row.svelte-b58rik{position:absolute;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.grid-row.svelte-b58rik:not(:last-child){border-bottom:1px solid #666}.grid-cell.svelte-b58rik{position:absolute;top:0;text-overflow:ellipsis;overflow:hidden}.grid-cell.svelte-b58rik>.svelte-b58rik{width:100%}.grid-cell.svelte-b58rik:not(:last-child){border-right:1px solid #666}";
    	append(document_1.head, style);
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.column = list[i];
    	child_ctx.j = i;
    	return child_ctx;
    }

    function get_each_context(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.row = list[i];
    	child_ctx.i = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.column = list[i];
    	child_ctx.i = i;
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.column = list[i];
    	child_ctx.i = i;
    	return child_ctx;
    }

    // (899:2) {#if __resizing || __columnDragging || __affixingColumn}
    function create_if_block_7(ctx) {
    	var div;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "column-action-line svelte-b58rik");
    			set_style(div, "left", "" + (ctx.__columnActionLineLeft - 2) + "px");
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);
    		},

    		p(changed, ctx) {
    			if (changed.__columnActionLineLeft) {
    				set_style(div, "left", "" + (ctx.__columnActionLineLeft - 2) + "px");
    			}
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}
    		}
    	};
    }

    // (904:2) {#if __affixingRow}
    function create_if_block_6(ctx) {
    	var div;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "row-action-line svelte-b58rik");
    			set_style(div, "top", "" + (ctx.__rowActionLineTop - 2) + "px");
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);
    		},

    		p(changed, ctx) {
    			if (changed.__rowActionLineTop) {
    				set_style(div, "top", "" + (ctx.__rowActionLineTop - 2) + "px");
    			}
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}
    		}
    	};
    }

    // (928:10) {:else}
    function create_else_block_1(ctx) {
    	var div, t_value = ctx.column.display || '' + "", t;

    	return {
    		c() {
    			div = element("div");
    			t = text(t_value);
    			attr(div, "class", "cell-default svelte-b58rik");
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t);
    		},

    		p(changed, ctx) {
    			if ((changed.columns) && t_value !== (t_value = ctx.column.display || '' + "")) {
    				set_data(t, t_value);
    			}
    		},

    		i: noop,
    		o: noop,

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}
    		}
    	};
    }

    // (926:10) {#if column.headerComponent}
    function create_if_block_5(ctx) {
    	var switch_instance_anchor, current;

    	var switch_value = ctx.column.headerComponent;

    	function switch_props(ctx) {
    		return { props: { column: ctx.column } };
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			if (switch_instance) switch_instance.$$.fragment.c();
    			switch_instance_anchor = empty();
    		},

    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},

    		p(changed, ctx) {
    			var switch_instance_changes = {};
    			if (changed.columns) switch_instance_changes.column = ctx.column;

    			if (switch_value !== (switch_value = ctx.column.headerComponent)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;
    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});
    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));

    					switch_instance.$$.fragment.c();
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}

    			else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},

    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

    			current = true;
    		},

    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(switch_instance_anchor);
    			}

    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (932:8) {#if allowResizeFromTableHeaders && !column.disallowResize}
    function create_if_block_4(ctx) {
    	var div, dispose;

    	function mousedown_handler_1(...args) {
    		return ctx.mousedown_handler_1(ctx, ...args);
    	}

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "grid-cell-size-capture svelte-b58rik");
    			set_style(div, "left", "" + (getCellLeft({
                  i: ctx.i,
                  columnWidths: ctx.columnWidths,
                  __affixedColumnIndices: ctx.__affixedColumnIndices,
                  __scrollLeft: ctx.__scrollLeft
                }) + ctx.columnWidths[ctx.i] - ctx.Math.floor(ctx.__columnHeaderResizeCaptureWidth / 2)) + "px");
    			set_style(div, "width", "" + ctx.__columnHeaderResizeCaptureWidth + "px");
    			dispose = listen(div, "mousedown", mousedown_handler_1);
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);
    		},

    		p(changed, new_ctx) {
    			ctx = new_ctx;
    			if (changed.columns || changed.columnWidths || changed.__affixedColumnIndices || changed.__scrollLeft || changed.__columnHeaderResizeCaptureWidth) {
    				set_style(div, "left", "" + (getCellLeft({
                  i: ctx.i,
                  columnWidths: ctx.columnWidths,
                  __affixedColumnIndices: ctx.__affixedColumnIndices,
                  __scrollLeft: ctx.__scrollLeft
                }) + ctx.columnWidths[ctx.i] - ctx.Math.floor(ctx.__columnHeaderResizeCaptureWidth / 2)) + "px");
    			}

    			if (changed.__columnHeaderResizeCaptureWidth) {
    				set_style(div, "width", "" + ctx.__columnHeaderResizeCaptureWidth + "px");
    			}
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			dispose();
    		}
    	};
    }

    // (916:6) {#each columns as column, i (i)}
    function create_each_block_3(key_1, ctx) {
    	var div, current_block_type_index, if_block0, div_title_value, dragCopy_action, t, if_block1_anchor, current, dispose;

    	var if_block_creators = [
    		create_if_block_5,
    		create_else_block_1
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.column.headerComponent) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function mousedown_handler(...args) {
    		return ctx.mousedown_handler(ctx, ...args);
    	}

    	var if_block1 = (ctx.allowResizeFromTableHeaders && !ctx.column.disallowResize) && create_if_block_4(ctx);

    	return {
    		key: key_1,

    		first: null,

    		c() {
    			div = element("div");
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			attr(div, "class", "grid-cell svelte-b58rik");
    			set_style(div, "z-index", ctx.getCellZIndex(ctx.__affixedColumnIndices, ctx.i));
    			set_style(div, "left", "" + getCellLeft(
                { i: ctx.i, columnWidths: ctx.columnWidths, __affixedColumnIndices: ctx.__affixedColumnIndices, __scrollLeft: ctx.__scrollLeft }
              ) + "px");
    			set_style(div, "width", "" + ctx.columnWidths[ctx.i] + "px");
    			set_style(div, "height", "" + ctx.rowHeight + "px");
    			set_style(div, "line-height", "" + ctx.rowHeight + "px");
    			attr(div, "title", div_title_value = ctx.column.display || '');
    			attr(div, "role", "columnheader");
    			dispose = listen(div, "mousedown", mousedown_handler);
    			this.first = div;
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			dragCopy_action = dragCopy.call(null, div, ctx.allowColumnReordering) || {};
    			insert(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    			current = true;
    		},

    		p(changed, new_ctx) {
    			ctx = new_ctx;
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block0 = if_blocks[current_block_type_index];
    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}
    				transition_in(if_block0, 1);
    				if_block0.m(div, null);
    			}

    			if (!current || changed.__affixedColumnIndices || changed.columns) {
    				set_style(div, "z-index", ctx.getCellZIndex(ctx.__affixedColumnIndices, ctx.i));
    			}

    			if (!current || changed.columns || changed.columnWidths || changed.__affixedColumnIndices || changed.__scrollLeft) {
    				set_style(div, "left", "" + getCellLeft(
                { i: ctx.i, columnWidths: ctx.columnWidths, __affixedColumnIndices: ctx.__affixedColumnIndices, __scrollLeft: ctx.__scrollLeft }
              ) + "px");
    			}

    			if (!current || changed.columnWidths || changed.columns) {
    				set_style(div, "width", "" + ctx.columnWidths[ctx.i] + "px");
    			}

    			if (!current || changed.rowHeight) {
    				set_style(div, "height", "" + ctx.rowHeight + "px");
    				set_style(div, "line-height", "" + ctx.rowHeight + "px");
    			}

    			if ((!current || changed.columns) && div_title_value !== (div_title_value = ctx.column.display || '')) {
    				attr(div, "title", div_title_value);
    			}

    			if (typeof dragCopy_action.update === 'function' && changed.allowColumnReordering) {
    				dragCopy_action.update.call(null, ctx.allowColumnReordering);
    			}

    			if (ctx.allowResizeFromTableHeaders && !ctx.column.disallowResize) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},

    		i(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},

    		o(local) {
    			transition_out(if_block0);
    			current = false;
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			if_blocks[current_block_type_index].d();
    			if (dragCopy_action && typeof dragCopy_action.destroy === 'function') dragCopy_action.destroy();

    			if (detaching) {
    				detach(t);
    			}

    			if (if_block1) if_block1.d(detaching);

    			if (detaching) {
    				detach(if_block1_anchor);
    			}

    			dispose();
    		}
    	};
    }

    // (956:4) {#if allowColumnAffix}
    function create_if_block_3(ctx) {
    	var div, dispose;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "column-affix-marker svelte-b58rik");
    			set_style(div, "left", "" + ctx.columnAffixLineLeft + "px");
    			set_style(div, "height", "" + ctx.gridSpaceHeight + "px");
    			dispose = listen(div, "mousedown", ctx.onColumnAffixStart);
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);
    		},

    		p(changed, ctx) {
    			if (changed.columnAffixLineLeft) {
    				set_style(div, "left", "" + ctx.columnAffixLineLeft + "px");
    			}

    			if (changed.gridSpaceHeight) {
    				set_style(div, "height", "" + ctx.gridSpaceHeight + "px");
    			}
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			dispose();
    		}
    	};
    }

    // (971:6) {#if allowResizeFromTableCells}
    function create_if_block_1(ctx) {
    	var each_1_anchor;

    	let each_value_2 = ctx.columns;

    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	return {
    		c() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},

    		m(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    		},

    		p(changed, ctx) {
    			if (changed.columns || changed.getCellLeft || changed.columnWidths || changed.__affixedColumnIndices || changed.__scrollLeft || changed.Math || changed.__columnHeaderResizeCaptureWidth) {
    				each_value_2 = ctx.columns;

    				let i;
    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_2.length;
    			}
    		},

    		d(detaching) {
    			destroy_each(each_blocks, detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (973:10) {#if !column.disallowResize}
    function create_if_block_2(ctx) {
    	var div, dispose;

    	function mousedown_handler_2(...args) {
    		return ctx.mousedown_handler_2(ctx, ...args);
    	}

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "grid-cell-size-capture svelte-b58rik");
    			set_style(div, "left", "" + (getCellLeft({
                    i: ctx.i + 1,
                    columnWidths: ctx.columnWidths,
                    __affixedColumnIndices: ctx.__affixedColumnIndices,
                    __scrollLeft: ctx.__scrollLeft
                  }) - ctx.Math.floor(ctx.__columnHeaderResizeCaptureWidth / 2)) + "px");
    			set_style(div, "width", "" + ctx.__columnHeaderResizeCaptureWidth + "px");
    			dispose = listen(div, "mousedown", mousedown_handler_2);
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);
    		},

    		p(changed, new_ctx) {
    			ctx = new_ctx;
    			if (changed.columnWidths || changed.__affixedColumnIndices || changed.__scrollLeft || changed.__columnHeaderResizeCaptureWidth) {
    				set_style(div, "left", "" + (getCellLeft({
                    i: ctx.i + 1,
                    columnWidths: ctx.columnWidths,
                    __affixedColumnIndices: ctx.__affixedColumnIndices,
                    __scrollLeft: ctx.__scrollLeft
                  }) - ctx.Math.floor(ctx.__columnHeaderResizeCaptureWidth / 2)) + "px");
    			}

    			if (changed.__columnHeaderResizeCaptureWidth) {
    				set_style(div, "width", "" + ctx.__columnHeaderResizeCaptureWidth + "px");
    			}
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			dispose();
    		}
    	};
    }

    // (972:8) {#each columns as column, i}
    function create_each_block_2(ctx) {
    	var if_block_anchor;

    	var if_block = (!ctx.column.disallowResize) && create_if_block_2(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p(changed, ctx) {
    			if (!ctx.column.disallowResize) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (1011:12) {:else}
    function create_else_block(ctx) {
    	var div, t_value = ctx.row.data[ctx.column.dataName] || '' + "", t;

    	return {
    		c() {
    			div = element("div");
    			t = text(t_value);
    			attr(div, "class", "cell-default svelte-b58rik");
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t);
    		},

    		p(changed, ctx) {
    			if ((changed.visibleRows || changed.columns) && t_value !== (t_value = ctx.row.data[ctx.column.dataName] || '' + "")) {
    				set_data(t, t_value);
    			}
    		},

    		i: noop,
    		o: noop,

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}
    		}
    	};
    }

    // (1004:12) {#if column.cellComponent}
    function create_if_block(ctx) {
    	var switch_instance_anchor, current;

    	var switch_value = ctx.column.cellComponent;

    	function switch_props(ctx) {
    		return {
    			props: {
    			rowNumber: ctx.row.i,
    			column: ctx.column,
    			row: ctx.row
    		}
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("valueupdate", ctx.onCellUpdated);
    	}

    	return {
    		c() {
    			if (switch_instance) switch_instance.$$.fragment.c();
    			switch_instance_anchor = empty();
    		},

    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},

    		p(changed, ctx) {
    			var switch_instance_changes = {};
    			if (changed.visibleRows) switch_instance_changes.rowNumber = ctx.row.i;
    			if (changed.columns) switch_instance_changes.column = ctx.column;
    			if (changed.visibleRows) switch_instance_changes.row = ctx.row;

    			if (switch_value !== (switch_value = ctx.column.cellComponent)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;
    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});
    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("valueupdate", ctx.onCellUpdated);

    					switch_instance.$$.fragment.c();
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}

    			else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},

    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

    			current = true;
    		},

    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(switch_instance_anchor);
    			}

    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (997:8) {#each columns as column, j}
    function create_each_block_1(ctx) {
    	var div, current_block_type_index, if_block, current;

    	var if_block_creators = [
    		create_if_block,
    		create_else_block
    	];

    	var if_blocks = [];

    	function select_block_type_1(changed, ctx) {
    		if (ctx.column.cellComponent) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c() {
    			div = element("div");
    			if_block.c();
    			attr(div, "class", "grid-cell svelte-b58rik");
    			set_style(div, "z-index", ctx.getCellZIndex(ctx.__affixedColumnIndices, ctx.j));
    			set_style(div, "left", "" + getCellLeft(
                  { i: ctx.j, columnWidths: ctx.columnWidths, __affixedColumnIndices: ctx.__affixedColumnIndices, __scrollLeft: ctx.__scrollLeft }
                ) + "px");
    			set_style(div, "height", "" + ctx.rowHeight + "px");
    			set_style(div, "line-height", "" + ctx.rowHeight + "px");
    			set_style(div, "width", "" + ctx.columnWidths[ctx.j] + "px");
    			attr(div, "role", "cell");
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},

    		p(changed, ctx) {
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (!current || changed.__affixedColumnIndices) {
    				set_style(div, "z-index", ctx.getCellZIndex(ctx.__affixedColumnIndices, ctx.j));
    			}

    			if (!current || changed.columnWidths || changed.__affixedColumnIndices || changed.__scrollLeft) {
    				set_style(div, "left", "" + getCellLeft(
                  { i: ctx.j, columnWidths: ctx.columnWidths, __affixedColumnIndices: ctx.__affixedColumnIndices, __scrollLeft: ctx.__scrollLeft }
                ) + "px");
    			}

    			if (!current || changed.rowHeight) {
    				set_style(div, "height", "" + ctx.rowHeight + "px");
    				set_style(div, "line-height", "" + ctx.rowHeight + "px");
    			}

    			if (!current || changed.columnWidths) {
    				set_style(div, "width", "" + ctx.columnWidths[ctx.j] + "px");
    			}
    		},

    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			if_blocks[current_block_type_index].d();
    		}
    	};
    }

    // (990:4) {#each visibleRows as row, i}
    function create_each_block(ctx) {
    	var div, t, div_aria_rowindex_value, current;

    	let each_value_1 = ctx.columns;

    	let each_blocks = [];

    	for (let i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
    		each_blocks[i_1] = create_each_block_1(get_each_context_1(ctx, each_value_1, i_1));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			div = element("div");

    			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
    				each_blocks[i_1].c();
    			}

    			t = space();
    			attr(div, "class", "grid-row svelte-b58rik");
    			set_style(div, "top", "" + ctx.getRowTop(ctx.row.i, ctx.rowHeight) + "px");
    			set_style(div, "height", "" + ctx.rowHeight + "px");
    			set_style(div, "width", "" + ctx.gridSpaceWidth + "px");
    			attr(div, "role", "row");
    			attr(div, "aria-rowindex", div_aria_rowindex_value = ctx.row.i);
    		},

    		m(target, anchor) {
    			insert(target, div, anchor);

    			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
    				each_blocks[i_1].m(div, null);
    			}

    			append(div, t);
    			current = true;
    		},

    		p(changed, ctx) {
    			if (changed.getCellZIndex || changed.__affixedColumnIndices || changed.getCellLeft || changed.columnWidths || changed.__scrollLeft || changed.rowHeight || changed.columns || changed.visibleRows) {
    				each_value_1 = ctx.columns;

    				let i_1;
    				for (i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i_1);

    					if (each_blocks[i_1]) {
    						each_blocks[i_1].p(changed, child_ctx);
    						transition_in(each_blocks[i_1], 1);
    					} else {
    						each_blocks[i_1] = create_each_block_1(child_ctx);
    						each_blocks[i_1].c();
    						transition_in(each_blocks[i_1], 1);
    						each_blocks[i_1].m(div, t);
    					}
    				}

    				group_outros();
    				for (i_1 = each_value_1.length; i_1 < each_blocks.length; i_1 += 1) {
    					out(i_1);
    				}
    				check_outros();
    			}

    			if (!current || changed.visibleRows || changed.rowHeight) {
    				set_style(div, "top", "" + ctx.getRowTop(ctx.row.i, ctx.rowHeight) + "px");
    			}

    			if (!current || changed.rowHeight) {
    				set_style(div, "height", "" + ctx.rowHeight + "px");
    			}

    			if (!current || changed.gridSpaceWidth) {
    				set_style(div, "width", "" + ctx.gridSpaceWidth + "px");
    			}

    			if ((!current || changed.visibleRows) && div_aria_rowindex_value !== (div_aria_rowindex_value = ctx.row.i)) {
    				attr(div, "aria-rowindex", div_aria_rowindex_value);
    			}
    		},

    		i(local) {
    			if (current) return;
    			for (let i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
    				transition_in(each_blocks[i_1]);
    			}

    			current = true;
    		},

    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);
    			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
    				transition_out(each_blocks[i_1]);
    			}

    			current = false;
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    function create_fragment(ctx) {
    	var div5, t0, t1, div1, div0, each_blocks_1 = [], each0_lookup = new Map(), t2, div4, t3, div2, t4, div3, t5, div4_resize_listener, div5_class_value, current, dispose;

    	var if_block0 = (ctx.__resizing || ctx.__columnDragging || ctx.__affixingColumn) && create_if_block_7(ctx);

    	var if_block1 = (ctx.__affixingRow) && create_if_block_6(ctx);

    	let each_value_3 = ctx.columns;

    	const get_key = ctx => ctx.i;

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		let child_ctx = get_each_context_3(ctx, each_value_3, i);
    		let key = get_key(child_ctx);
    		each0_lookup.set(key, each_blocks_1[i] = create_each_block_3(key, child_ctx));
    	}

    	var if_block2 = (ctx.allowColumnAffix) && create_if_block_3(ctx);

    	var if_block3 = (ctx.allowResizeFromTableCells) && create_if_block_1(ctx);

    	let each_value = ctx.visibleRows;

    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			div5 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t2 = space();
    			div4 = element("div");
    			if (if_block2) if_block2.c();
    			t3 = space();
    			div2 = element("div");
    			t4 = space();
    			div3 = element("div");
    			if (if_block3) if_block3.c();
    			t5 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(div0, "class", "grid-header-row svelte-b58rik");
    			set_style(div0, "left", "-" + ctx.__scrollLeft + "px");
    			set_style(div0, "height", "" + ctx.rowHeight + "px");
    			set_style(div0, "width", "" + ctx.gridSpaceWidth + "px");
    			attr(div0, "role", "row");
    			attr(div1, "class", "grid-headers svelte-b58rik");
    			set_style(div1, "height", "" + ctx.rowHeight + "px");
    			attr(div1, "rolw", "rowgroup");
    			attr(div2, "class", "row-affix-marker svelte-b58rik");
    			set_style(div2, "top", "" + ctx.__rowAffixLineTop + "px");
    			set_style(div2, "width", "" + ctx.gridSpaceWidth + "px");
    			attr(div3, "class", "grid-space svelte-b58rik");
    			set_style(div3, "width", "" + ctx.gridSpaceWidth + "px");
    			set_style(div3, "height", "" + ctx.gridSpaceHeight + "px");
    			add_render_callback(() => ctx.div4_resize_handler.call(div4));
    			attr(div4, "class", "grid-inner svelte-b58rik");
    			set_style(div4, "height", "100%");
    			attr(div4, "role", "rowgroup");
    			attr(div5, "class", div5_class_value = "data-grid-wrapper " + (ctx.__resizing || ctx.__columnDragging ? 'resizing' : '') + " svelte-b58rik");
    			set_style(div5, "padding-top", "" + ctx.rowHeight + "px");
    			attr(div5, "role", "table");

    			dispose = [
    				listen(window_1, "mouseup", ctx.onMouseUp),
    				listen(window_1, "mousemove", ctx.onMouseMove),
    				listen(window_1, "keydown", ctx.onWindowKeyDown),
    				listen(div2, "mousedown", ctx.onRowAffixStart),
    				listen(div4, "scroll", ctx.onScroll)
    			];
    		},

    		m(target, anchor) {
    			insert(target, div5, anchor);
    			if (if_block0) if_block0.m(div5, null);
    			append(div5, t0);
    			if (if_block1) if_block1.m(div5, null);
    			append(div5, t1);
    			append(div5, div1);
    			append(div1, div0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div0, null);
    			}

    			append(div5, t2);
    			append(div5, div4);
    			if (if_block2) if_block2.m(div4, null);
    			append(div4, t3);
    			append(div4, div2);
    			append(div4, t4);
    			append(div4, div3);
    			if (if_block3) if_block3.m(div3, null);
    			append(div4, t5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div4, null);
    			}

    			div4_resize_listener = add_resize_listener(div4, ctx.div4_resize_handler.bind(div4));
    			ctx.div4_binding(div4);
    			ctx.div5_binding(div5);
    			current = true;
    		},

    		p(changed, ctx) {
    			if (ctx.__resizing || ctx.__columnDragging || ctx.__affixingColumn) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					if_block0.m(div5, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.__affixingRow) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_6(ctx);
    					if_block1.c();
    					if_block1.m(div5, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			const each_value_3 = ctx.columns;

    			group_outros();
    			each_blocks_1 = update_keyed_each(each_blocks_1, changed, get_key, 1, ctx, each_value_3, each0_lookup, div0, outro_and_destroy_block, create_each_block_3, null, get_each_context_3);
    			check_outros();

    			if (!current || changed.__scrollLeft) {
    				set_style(div0, "left", "-" + ctx.__scrollLeft + "px");
    			}

    			if (!current || changed.rowHeight) {
    				set_style(div0, "height", "" + ctx.rowHeight + "px");
    			}

    			if (!current || changed.gridSpaceWidth) {
    				set_style(div0, "width", "" + ctx.gridSpaceWidth + "px");
    			}

    			if (!current || changed.rowHeight) {
    				set_style(div1, "height", "" + ctx.rowHeight + "px");
    			}

    			if (ctx.allowColumnAffix) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    				} else {
    					if_block2 = create_if_block_3(ctx);
    					if_block2.c();
    					if_block2.m(div4, t3);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (!current || changed.__rowAffixLineTop) {
    				set_style(div2, "top", "" + ctx.__rowAffixLineTop + "px");
    			}

    			if (!current || changed.gridSpaceWidth) {
    				set_style(div2, "width", "" + ctx.gridSpaceWidth + "px");
    			}

    			if (ctx.allowResizeFromTableCells) {
    				if (if_block3) {
    					if_block3.p(changed, ctx);
    				} else {
    					if_block3 = create_if_block_1(ctx);
    					if_block3.c();
    					if_block3.m(div3, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (!current || changed.gridSpaceWidth) {
    				set_style(div3, "width", "" + ctx.gridSpaceWidth + "px");
    			}

    			if (!current || changed.gridSpaceHeight) {
    				set_style(div3, "height", "" + ctx.gridSpaceHeight + "px");
    			}

    			if (changed.getRowTop || changed.visibleRows || changed.rowHeight || changed.gridSpaceWidth || changed.columns || changed.getCellZIndex || changed.__affixedColumnIndices || changed.getCellLeft || changed.columnWidths || changed.__scrollLeft) {
    				each_value = ctx.visibleRows;

    				let i;
    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div4, null);
    					}
    				}

    				group_outros();
    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}
    				check_outros();
    			}

    			if ((!current || changed.__resizing || changed.__columnDragging) && div5_class_value !== (div5_class_value = "data-grid-wrapper " + (ctx.__resizing || ctx.__columnDragging ? 'resizing' : '') + " svelte-b58rik")) {
    				attr(div5, "class", div5_class_value);
    			}

    			if (!current || changed.rowHeight) {
    				set_style(div5, "padding-top", "" + ctx.rowHeight + "px");
    			}
    		},

    		i(local) {
    			if (current) return;
    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},

    		o(local) {
    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},

    		d(detaching) {
    			if (detaching) {
    				detach(div5);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].d();
    			}

    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();

    			destroy_each(each_blocks, detaching);

    			div4_resize_listener.cancel();
    			ctx.div4_binding(null);
    			ctx.div5_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    const MIN_COLUMN_SIZE = 30;

    function getCellLeft({
      i,
      columnWidths,
      __affixedColumnIndices,
      __scrollLeft
    }) {
      if (__affixedColumnIndices.indexOf(i) >= 0) {
        if (i === 0) {
          return __scrollLeft;
        }
        let left = __scrollLeft;
        for (let j = i - 1; j >= 0; j--) {
          left += columnWidths[j];
        }
        return left;
      }

      let left = 0;
      for (let j = 0; j < i; j++) {
        left += columnWidths[j];
      }
      return left;
    }

    function getClosestIndex(
      x,
      columnWidths,
      __affixedColumnIndices,
      __scrollLeft
    ) {
      let closest = 0;

      for (let i = 0; i < columnWidths.length; i++) {
        const left =
          getCellLeft({ i, columnWidths, __affixedColumnIndices, __scrollLeft }) +
          Math.floor(columnWidths[i] / 2);

        if (left < x) {
          closest = i + 1;
        }
      }

      // special handling required when there are affixed columns, because
      // if the grid is scrolled horizontally to the right, we want to have this function return the closest
      // affixed column, rather than any columns that might be closer to x but are being overlapped by an affixed column
      if (__affixedColumnIndices.length > 0) {
        const firstAffixedLeft = getCellLeft({
          i: __affixedColumnIndices[0],
          columnWidths,
          __affixedColumnIndices,
          __scrollLeft
        });
        const lastAffixedLeft = getCellLeft({
          i: __affixedColumnIndices[__affixedColumnIndices.length - 1],
          columnWidths,
          __affixedColumnIndices,
          __scrollLeft
        });
        const lastAffixedRight =
          lastAffixedLeft +
          columnWidths[__affixedColumnIndices[__affixedColumnIndices.length - 1]];
        const closestLeft = getCellLeft({
          i: closest,
          columnWidths,
          __affixedColumnIndices,
          __scrollLeft
        });
        if (closestLeft > firstAffixedLeft && closestLeft < lastAffixedRight) {
          if (closestLeft < lastAffixedRight && closestLeft > lastAffixedLeft) {
            closest = __affixedColumnIndices[__affixedColumnIndices.length - 1];
          } else {
            for (let i = 0; i < __affixedColumnIndices.length; i++) {
              const left =
                getCellLeft({
                  i: __affixedColumnIndices[i],
                  columnWidths,
                  __affixedColumnIndices,
                  __scrollLeft
                }) + Math.floor(columnWidths[__affixedColumnIndices[i]] / 2);

              if (left < x) {
                closest = __affixedColumnIndices[i] + 1;
              }
            }
          }
        }
      }

      return closest;
    }

    function getBodyScrollTop() {
      return (
        window.pageYOffset ||
        (document.documentElement.clientHeight
          ? document.documentElement.scrollTop
          : document.body.scrollTop)
      );
    }

    function dragCopy(node, enabled) {
      let copy = null;
      let dragging = false;
      let offsetX = 0;

      function onWindowMouseMove(event) {
        if (!dragging) {
          return;
        }
        copy.style.left = event.pageX - offsetX + "px";
      }

      function onWindowMouseUp(event) {
        if (!dragging || event.which !== 1) {
          return;
        }

        dragging = false;
        document.body.removeChild(copy);
        copy = null;
      }

      function onNodeMouseDown(event) {
        if (event.which !== 1) {
          return;
        }

        dragging = true;
        if (copy) {
          document.body.removeChild(copy);
        }

        copy = createCopy();
        offsetX = event.offsetX;
        copy.style.top =
          node.getBoundingClientRect().top + getBodyScrollTop() + "px";
        copy.style.left = event.pageX - offsetX + "px";
        document.body.appendChild(copy);
      }

      function createCopy() {
        const copy = document.createElement("div");
        copy.innerHTML = node.innerHTML;
        const { width, height, textAlign, fontWeight } = getComputedStyle(node);
        copy.style.width = width;
        copy.style.height = height;
        copy.style.maxHeight = height;
        copy.style.textAlign = textAlign;
        copy.style.fontWeight = fontWeight;
        copy.style.position = "absolute";
        copy.style.opacity = "0.5";
        copy.style.pointerEvents = "none";
        copy.style.overflow = "hidden";
        copy.style.background = "#dddddd";
        copy.style["z-index"] = "99999";

        return copy;
      }

      function attachEvents() {
        window.addEventListener("mousemove", onWindowMouseMove);
        window.addEventListener("mouseup", onWindowMouseUp);
        node.addEventListener("mousedown", onNodeMouseDown);
      }

      function detachEvents() {
        window.removeEventListener("mousemove", onWindowMouseMove);
        window.removeEventListener("mouseup", onWindowMouseUp);
        node.removeEventListener("mousedown", onNodeMouseDown);
      }
      if (enabled) {
        attachEvents();
      }

      return {
        destroy() {
          detachEvents();
        },
        update(enabled) {
          if (enabled) {
            attachEvents();
          } else {
            detachEvents();
          }
        }
      };
    }

    function instance($$self, $$props, $$invalidate) {
    	

      const dispatch = createEventDispatcher();

      let wrapper;
      let tableSpace;

      let editHistory = null;

      let { rows = [], columns = [], rowHeight = 24, allowResizeFromTableCells = false, allowResizeFromTableHeaders = true, allowColumnReordering = true, allowColumnAffix = true, __extraRows = 0, __columnHeaderResizeCaptureWidth = 20, __affixedRowIndices = [], __affixedColumnIndices = [], __affixingRow = false, __affixingColumn = false, __rowActionLineTop = 0, __rowAffixLineTop = 0, __columnAffixLineLeft = 0, __columnDragging = false, __columnIndexBeingDragged = null, __columnDragOffsetX = 0, __resizing = false, __columnIndexBeingResized = null, __columnActionLineLeft = 0, __innerOffsetHeight = 0, __scrollTop = 0, __scrollLeft = 0, __scrolledAllTheWayToTheRight = false } = $$props; // DO NOT MODIFY DIRECTLY. Whether the container is scrolled all the way to the right as of the last onscroll event

      onMount(() => {
        editHistory = new EditHistory(rows);
      });

      function onWindowKeyDown(event) {
        if (event.ctrlKey) {
          if (event.keyCode === 90) {
            undo();
            event.preventDefault();
          }

          if (event.keyCode === 89) {
            redo();
            event.preventDefault();
          }
        }
      }

      /**
       * Event handler for window's mousemove event
       * @param {MouseEvent} event The MouseEvent object
       */
      function onMouseMove(event) {
        onColumnDragMouseMove(event);
        onColumnResizeMouseMove(event);
        onColumnAffixMouseMove(event);
      }

      /**
       * Event handler for window's mouseup event
       * @param {MouseEvent} event The MouseEvent object
       */
      function onMouseUp(event) {
        onColumnDragEnd(event);
        onColumnResizeEnd();
        onRowAffixEnd();
        onColumnAffixEnd();
      }

      /**
       * Event handler for when a value has been updated
       * @param {Object} event Event object with row and column objects
       */
      function onCellUpdated(event) {
        $$invalidate('rows', rows[event.detail.rowNumber][event.detail.column.dataName] =
          event.detail.value, rows);
        dispatch("valueUpdated", event);
      }

      /**
       * Applies the most recent backward change
       */
      function undo() {
        const eRows = editHistory.undo();
        if (eRows) {
          $$invalidate('rows', rows = eRows);
        }
      }

      /**
       * Applies the most recent forward change
       */

      function redo() {
        const eRows = editHistory.redo();
        if (eRows) {
          $$invalidate('rows', rows = eRows);
        }
      }

      /**
       * Event handler for starting column affix operation
       */
      function onColumnAffixStart(event) {
        // left click only
        if (event.which !== 1) {
          return;
        }
        if (__affixedColumnIndices.length > 0) {
          $$invalidate('tableSpace', tableSpace.scrollLeft = 0, tableSpace);
          $$invalidate('__affixingColumn', __affixingColumn = true);
        } else {
          $$invalidate('__affixingColumn', __affixingColumn = true);
        }
      }

      /**
       * Event handler for mousemove column affix operation
       */
      function onColumnAffixMouseMove(event) {
        if (!__affixingColumn) {
          return;
        }

        if (event.which !== 1) {
          onColumnAffixEnd();
          return;
        }

        const { left: wrapperPageX } = wrapper.getBoundingClientRect();

        const offsetPoint = event.pageX - wrapperPageX + __scrollLeft;

        const idx = getClosestIndex(
          offsetPoint,
          columnWidths,
          __affixedColumnIndices,
          __scrollLeft
        );
        const indices = [];
        for (let i = 0; i < idx; i++) {
          indices.push(i);
        }

        $$invalidate('__columnActionLineLeft', __columnActionLineLeft = offsetPoint);
        $$invalidate('__affixedColumnIndices', __affixedColumnIndices = indices);
        event.preventDefault();

        // check to see if horizontal scroll position doesn't match where the
      }

      /**
       * Event handler for ending column affix operation
       */
      function onColumnAffixEnd(event) {
        $$invalidate('__affixingColumn', __affixingColumn = false);
      }

      /**
       * Event handler for starting row affix operation
       */
      function onRowAffixStart(event) {
        $$invalidate('__affixingRow', __affixingRow = true);
      }

      /**
       * Event handler for ending row affix operation
       */
      function onRowAffixEnd(event) {
        $$invalidate('__affixingRow', __affixingRow = false);
      }

      /**
       * Event handler for column dragging
       */
      function onColumnDragStart(event, columnIndex) {
        if (event.which !== 1) {
          return;
        }

        // if the developer has disabled column reordering, don't begin a reorder
        if (!allowColumnReordering) {
          return;
        }

        $$invalidate('__columnDragging', __columnDragging = true);
        $$invalidate('__columnIndexBeingDragged', __columnIndexBeingDragged = columnIndex);
        $$invalidate('__columnDragOffsetX', __columnDragOffsetX = event.offsetX);
        $$invalidate('__columnActionLineLeft', __columnActionLineLeft =
          getCellLeft({
            i: columnIndex,
            columnWidths,
            __scrollLeft,
            __affixedColumnIndices
          }) - __scrollLeft);
      }

      function onColumnDragMouseMove(event) {
        if (!__columnDragging) {
          return;
        }

        // if user is no longer pressing the left mouse button and we are out of sync
        // with __columnDragging because mouseup didn't fire, finish the reorder
        if (event.which !== 1) {
          onColumnDragEnd(event);
          return;
        }

        const { left: wrapperPageX } = wrapper.getBoundingClientRect();

        // change the position of the action line to the closest column index under the mouse
        const offsetPoint =
          event.pageX - wrapperPageX + __scrollLeft - __columnDragOffsetX;
        const idx = getClosestIndex(
          offsetPoint,
          columnWidths,
          __affixedColumnIndices,
          __scrollLeft
        );
        $$invalidate('__columnActionLineLeft', __columnActionLineLeft =
          getCellLeft({
            i: idx,
            columnWidths,
            __affixedColumnIndices,
            __scrollLeft
          }) - __scrollLeft);
      }

      /**
       * Window mouseup handler for column dragging
       */
      function onColumnDragEnd(event) {
        // user might try to be clever and middle-click to scroll horizontally while dragging a column
        // don't stop the drag for middle clicks
        if (event.which !== 1) {
          return;
        }

        // if a column isn't being dragged, don't reorder anything
        if (!__columnDragging) {
          return;
        }

        const { left: wrapperPageX } = wrapper.getBoundingClientRect();
        const offsetPoint =
          event.pageX - wrapperPageX + __scrollLeft - __columnDragOffsetX;

        // move column object to its new position in the array based off the mouse position and scroll position
        const newIdx = getClosestIndex(
          offsetPoint,
          columnWidths,
          __affixedColumnIndices,
          __scrollLeft
        );
        let mColumns = columns;
        mColumns.splice(
          newIdx > __columnIndexBeingDragged ? newIdx - 1 : newIdx,
          0,
          mColumns.splice(__columnIndexBeingDragged, 1)[0]
        );
        $$invalidate('columns', columns = mColumns);
        // delay firing of event so that new column order is accessible when handlers are called
        setTimeout(() => dispatch("columnOrderUpdated"), 0);

        $$invalidate('__columnDragging', __columnDragging = false);
        $$invalidate('__columnDragOffsetX', __columnDragOffsetX = 0);
        $$invalidate('__columnIndexBeingDragged', __columnIndexBeingDragged = null);
      }

      /**
       * Mousedown handler for column resizing
       */
      function onColumnResizeStart(event, columnIndex) {
        // left click only
        if (event.which !== 1) {
          return;
        }
        const { left: wrapperPageX } = wrapper.getBoundingClientRect();

        $$invalidate('__resizing', __resizing = true);
        $$invalidate('__columnActionLineLeft', __columnActionLineLeft = event.pageX - wrapperPageX - __scrollLeft);
        $$invalidate('__columnIndexBeingResized', __columnIndexBeingResized = columnIndex);
        event.stopPropagation();
      }

      /**
       * Mousemove handler for column resizing
       */
      function onColumnResizeMouseMove(event) {
        // if not currently resizing a column, ignore the event
        if (!__resizing) {
          return;
        }

        const { left: wrapperPageX } = wrapper.getBoundingClientRect();

        const resizeLineLeft = event.pageX - wrapperPageX;
        const columnLeft = getCellLeft({
          i: __columnIndexBeingResized,
          columnWidths,
          __affixedColumnIndices,
          __scrollLeft
        });
        const resizeLineMinLeft = columnLeft - __scrollLeft + MIN_COLUMN_SIZE;
        const newColumnWidth = Math.max(
          resizeLineLeft + __scrollLeft - columnLeft,
          MIN_COLUMN_SIZE
        );
        // thanks to the virtual list, we're able to get away with setting the column's size while the mouse moves
        $$invalidate('columns', columns[__columnIndexBeingResized].width = newColumnWidth, columns);

        $$invalidate('__columnActionLineLeft', __columnActionLineLeft = Math.max(resizeLineLeft, resizeLineMinLeft));

        // If mouseup was not fired for some reason, abort the resize
        if (event.which !== 1) {
          $$invalidate('__resizing', __resizing = false);
          $$invalidate('__columnIndexBeingResized', __columnIndexBeingResized = null);

          // delay firing the event until the next frame to guarantee that new values will be available in component.get()
          setTimeout(
            () =>
              dispatch("columnWidthUpdated", {
                idx: __columnIndexBeingResized,
                width: newColumnWidth
              }),
            0
          );
        }

        // if still resizing and the user does not have the left mouse button depressed,
        // the mouseup event didn't fire for some reason, so turn off the resize mode
      }

      /**
       * Mouseup handler for column resizing
       */
      function onColumnResizeEnd(event) {
        if (!__resizing) {
          return;
        }

        dispatch("columnWidthUpdated");
        $$invalidate('__resizing', __resizing = false);
        $$invalidate('__columnIndexBeingResized', __columnIndexBeingResized = null);
      }

      /**
       * Sets updated scroll values when the scrollable area is scrolled
       */
      function onScroll() {
        // get new scroll values from the scroll area
        const { scrollTop: newScrollTop, scrollLeft: newScrollLeft } = tableSpace;

        /*
         * To avoid doing unnecessary re-calculation of computed variables, don't set the scroll
         * properties that haven't changed
         */
        if (__scrollTop !== newScrollTop) {
          $$invalidate('__scrollTop', __scrollTop = newScrollTop);
        }

        if (__scrollLeft !== newScrollLeft) {
          $$invalidate('__scrollLeft', __scrollLeft = newScrollLeft);
        }

        $$invalidate('__scrolledAllTheWayToTheRight', __scrolledAllTheWayToTheRight =
          Math.ceil(tableSpace.scrollWidth - tableSpace.scrollLeft) ===
          tableSpace.clientWidth);
      }

      /**
       * Computed Properties
       */

      /**
       * The 'left' value of the column affix line
       */

      let columnAffixLineLeft = 0;

      /**
       * Array of column widths
       */
      let columnWidths = columns.map(x => x.width || MIN_COLUMN_SIZE);

      /**
       * The number of rows we have
       */
      let numRows = rows.length;

      /**
       * Width of the overall grid space
       */
      let gridSpaceWidth = 0;

      /**
       * Height of the overall grid space
       */
      let gridSpaceHeight = rowHeight * numRows;

      /**
       * Number of rows to render in the viewport
       */
      let numRowsInViewport = Math.ceil(__innerOffsetHeight / rowHeight);

      /**
       * Computes which rows should be visible
       */
      let visibleRows;

      /**
       * Helpers
       */
      const getCellZIndex = function(__affixedColumnIndices, i) {
        return __affixedColumnIndices.indexOf(i) === -1 ? 1 : 2;
      };

      /**
       * Gets the 'top' value for a grid-row
       */
      const getRowTop = function(i, rowHeight) {
        return i * rowHeight;
      };

      // const getCellLeft =getCellLeft

    	const mousedown_handler = ({ i }, event) => onColumnDragStart(event, i);

    	const mousedown_handler_1 = ({ i }, event) => onColumnResizeStart(event, i);

    	const mousedown_handler_2 = ({ i }, event) => onColumnResizeStart(event, i);

    	function div4_resize_handler() {
    		__innerOffsetHeight = this.offsetHeight;
    		$$invalidate('__innerOffsetHeight', __innerOffsetHeight);
    	}

    	function div4_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('tableSpace', tableSpace = $$value);
    		});
    	}

    	function div5_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('wrapper', wrapper = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('rows' in $$props) $$invalidate('rows', rows = $$props.rows);
    		if ('columns' in $$props) $$invalidate('columns', columns = $$props.columns);
    		if ('rowHeight' in $$props) $$invalidate('rowHeight', rowHeight = $$props.rowHeight);
    		if ('allowResizeFromTableCells' in $$props) $$invalidate('allowResizeFromTableCells', allowResizeFromTableCells = $$props.allowResizeFromTableCells);
    		if ('allowResizeFromTableHeaders' in $$props) $$invalidate('allowResizeFromTableHeaders', allowResizeFromTableHeaders = $$props.allowResizeFromTableHeaders);
    		if ('allowColumnReordering' in $$props) $$invalidate('allowColumnReordering', allowColumnReordering = $$props.allowColumnReordering);
    		if ('allowColumnAffix' in $$props) $$invalidate('allowColumnAffix', allowColumnAffix = $$props.allowColumnAffix);
    		if ('__extraRows' in $$props) $$invalidate('__extraRows', __extraRows = $$props.__extraRows);
    		if ('__columnHeaderResizeCaptureWidth' in $$props) $$invalidate('__columnHeaderResizeCaptureWidth', __columnHeaderResizeCaptureWidth = $$props.__columnHeaderResizeCaptureWidth);
    		if ('__affixedRowIndices' in $$props) $$invalidate('__affixedRowIndices', __affixedRowIndices = $$props.__affixedRowIndices);
    		if ('__affixedColumnIndices' in $$props) $$invalidate('__affixedColumnIndices', __affixedColumnIndices = $$props.__affixedColumnIndices);
    		if ('__affixingRow' in $$props) $$invalidate('__affixingRow', __affixingRow = $$props.__affixingRow);
    		if ('__affixingColumn' in $$props) $$invalidate('__affixingColumn', __affixingColumn = $$props.__affixingColumn);
    		if ('__rowActionLineTop' in $$props) $$invalidate('__rowActionLineTop', __rowActionLineTop = $$props.__rowActionLineTop);
    		if ('__rowAffixLineTop' in $$props) $$invalidate('__rowAffixLineTop', __rowAffixLineTop = $$props.__rowAffixLineTop);
    		if ('__columnAffixLineLeft' in $$props) $$invalidate('__columnAffixLineLeft', __columnAffixLineLeft = $$props.__columnAffixLineLeft);
    		if ('__columnDragging' in $$props) $$invalidate('__columnDragging', __columnDragging = $$props.__columnDragging);
    		if ('__columnIndexBeingDragged' in $$props) $$invalidate('__columnIndexBeingDragged', __columnIndexBeingDragged = $$props.__columnIndexBeingDragged);
    		if ('__columnDragOffsetX' in $$props) $$invalidate('__columnDragOffsetX', __columnDragOffsetX = $$props.__columnDragOffsetX);
    		if ('__resizing' in $$props) $$invalidate('__resizing', __resizing = $$props.__resizing);
    		if ('__columnIndexBeingResized' in $$props) $$invalidate('__columnIndexBeingResized', __columnIndexBeingResized = $$props.__columnIndexBeingResized);
    		if ('__columnActionLineLeft' in $$props) $$invalidate('__columnActionLineLeft', __columnActionLineLeft = $$props.__columnActionLineLeft);
    		if ('__innerOffsetHeight' in $$props) $$invalidate('__innerOffsetHeight', __innerOffsetHeight = $$props.__innerOffsetHeight);
    		if ('__scrollTop' in $$props) $$invalidate('__scrollTop', __scrollTop = $$props.__scrollTop);
    		if ('__scrollLeft' in $$props) $$invalidate('__scrollLeft', __scrollLeft = $$props.__scrollLeft);
    		if ('__scrolledAllTheWayToTheRight' in $$props) $$invalidate('__scrolledAllTheWayToTheRight', __scrolledAllTheWayToTheRight = $$props.__scrolledAllTheWayToTheRight);
    	};

    	$$self.$$.update = ($$dirty = { columns: 1, __affixedColumnIndices: 1, __scrollLeft: 1, columnWidths: 1, rows: 1, __resizing: 1, __scrolledAllTheWayToTheRight: 1, rowHeight: 1, numRows: 1, __innerOffsetHeight: 1, __scrollTop: 1, __extraRows: 1, numRowsInViewport: 1 }) => {
    		if ($$dirty.columns) { {
            // if width was not provided for this column, give it a default value
            $$invalidate('columnWidths', columnWidths = columns.map(x => x.width || MIN_COLUMN_SIZE));
          } }
    		if ($$dirty.__affixedColumnIndices || $$dirty.__scrollLeft || $$dirty.columnWidths) { {
            // if no columns are affixed, set the line all the way to the left
            if (__affixedColumnIndices.length === 0) {
              $$invalidate('columnAffixLineLeft', columnAffixLineLeft = 0);
            }
        
            let left = __scrollLeft;
            for (let i = 0; i < __affixedColumnIndices.length; i++) {
              left += columnWidths[__affixedColumnIndices[i]];
            }
        
            $$invalidate('columnAffixLineLeft', columnAffixLineLeft = left);
          } }
    		if ($$dirty.rows) { {
            $$invalidate('numRows', numRows = rows.length);
          } }
    		if ($$dirty.columnWidths || $$dirty.__resizing || $$dirty.__scrolledAllTheWayToTheRight) { {
            let sum = 0;
            for (let i = 0; i < columnWidths.length; i++) {
              sum += columnWidths[i];
            }
        
            /**
             * If the table is scrolled all the way to the right, resizing columns could
             * accelerate until the column is the minimum width. Add some extra space on the right
             * to ensure this undesired behavior does not happen. This doesn't seem like a perfect solution
             * but it works for now until I can think of something better.
             */
        
            if (__resizing && __scrolledAllTheWayToTheRight) {
              sum *= 2;
            }
        
            $$invalidate('gridSpaceWidth', gridSpaceWidth = sum);
          } }
    		if ($$dirty.rowHeight || $$dirty.numRows) { {
            $$invalidate('gridSpaceHeight', gridSpaceHeight = rowHeight * numRows);
          } }
    		if ($$dirty.__innerOffsetHeight || $$dirty.rowHeight) { {
            $$invalidate('numRowsInViewport', numRowsInViewport = Math.ceil(__innerOffsetHeight / rowHeight));
          } }
    		if ($$dirty.__scrollTop || $$dirty.rowHeight || $$dirty.__extraRows || $$dirty.numRowsInViewport || $$dirty.rows) { {
            const start = Math.max(
              0,
              Math.floor(__scrollTop / rowHeight - __extraRows / 2)
            );
            const end = start + numRowsInViewport + __extraRows;
        
            $$invalidate('visibleRows', visibleRows = rows.slice(start, end).map((x, i) => {
              return {
                i: i + start, // for aria-rowindex
                data: x // the row data
              };
            }));
          } }
    	};

    	return {
    		wrapper,
    		tableSpace,
    		rows,
    		columns,
    		rowHeight,
    		allowResizeFromTableCells,
    		allowResizeFromTableHeaders,
    		allowColumnReordering,
    		allowColumnAffix,
    		__extraRows,
    		__columnHeaderResizeCaptureWidth,
    		__affixedRowIndices,
    		__affixedColumnIndices,
    		__affixingRow,
    		__affixingColumn,
    		__rowActionLineTop,
    		__rowAffixLineTop,
    		__columnAffixLineLeft,
    		__columnDragging,
    		__columnIndexBeingDragged,
    		__columnDragOffsetX,
    		__resizing,
    		__columnIndexBeingResized,
    		__columnActionLineLeft,
    		__innerOffsetHeight,
    		__scrollTop,
    		__scrollLeft,
    		__scrolledAllTheWayToTheRight,
    		onWindowKeyDown,
    		onMouseMove,
    		onMouseUp,
    		onCellUpdated,
    		onColumnAffixStart,
    		onRowAffixStart,
    		onColumnDragStart,
    		onColumnResizeStart,
    		onScroll,
    		columnAffixLineLeft,
    		columnWidths,
    		gridSpaceWidth,
    		gridSpaceHeight,
    		visibleRows,
    		getCellZIndex,
    		getRowTop,
    		Math,
    		mousedown_handler,
    		mousedown_handler_1,
    		mousedown_handler_2,
    		div4_resize_handler,
    		div4_binding,
    		div5_binding
    	};
    }

    class Index extends SvelteComponent {
    	constructor(options) {
    		super();
    		if (!document_1.getElementById("svelte-b58rik-style")) add_css();
    		init(this, options, instance, create_fragment, safe_not_equal, ["rows", "columns", "rowHeight", "allowResizeFromTableCells", "allowResizeFromTableHeaders", "allowColumnReordering", "allowColumnAffix", "__extraRows", "__columnHeaderResizeCaptureWidth", "__affixedRowIndices", "__affixedColumnIndices", "__affixingRow", "__affixingColumn", "__rowActionLineTop", "__rowAffixLineTop", "__columnAffixLineLeft", "__columnDragging", "__columnIndexBeingDragged", "__columnDragOffsetX", "__resizing", "__columnIndexBeingResized", "__columnActionLineLeft", "__innerOffsetHeight", "__scrollTop", "__scrollLeft", "__scrolledAllTheWayToTheRight"]);
    	}
    }

    return Index;

}));
