import { F as identity, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, A as create_slot, v as validate_slots, G as svg_element, t as text, H as claim_svg_element, b as children, u as claim_text, g as detach_dev, j as add_location, m as insert_hydration_dev, n as append_hydration_dev, I as set_data_dev, J as empty, h as attr_dev, B as update_slot_base, C as get_all_dirty_from_scope, D as get_slot_changes, x as transition_in, y as transition_out, K as assign, L as exclude_internal_props, p as create_component, r as claim_component, w as mount_component, M as get_spread_update, N as get_spread_object, z as destroy_component, O as validate_each_argument, e as element, a as space, c as claim_element, f as claim_space, k as src_url_equal, P as listen_dev, Q as add_render_callback, R as create_in_transition, o as noop, T as destroy_each, E as onMount, q as query_selector_all } from './client.3130cdf4.js';
import { P as PageHeader } from './PageHeader.307a79b2.js';

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}

/* node_modules/svelte-icons/components/IconBase.svelte generated by Svelte v3.45.0 */

const file = "node_modules/svelte-icons/components/IconBase.svelte";

// (9:2) {#if title}
function create_if_block(ctx) {
	let title_1;
	let t;

	const block = {
		c: function create() {
			title_1 = svg_element("title");
			t = text(/*title*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			title_1 = claim_svg_element(nodes, "title", {});
			var title_1_nodes = children(title_1);
			t = claim_text(title_1_nodes, /*title*/ ctx[0]);
			title_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(title_1, file, 9, 4, 251);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, title_1, anchor);
			append_hydration_dev(title_1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(title_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(9:2) {#if title}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let svg;
	let if_block_anchor;
	let current;
	let if_block = /*title*/ ctx[0] && create_if_block(ctx);
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			if_block_anchor = empty();
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true, class: true });
			var svg_nodes = children(svg);
			if (if_block) if_block.l(svg_nodes);
			if_block_anchor = empty();
			if (default_slot) default_slot.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", /*viewBox*/ ctx[1]);
			attr_dev(svg, "class", "svelte-1idglq6");
			add_location(svg, file, 7, 0, 182);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
			append_hydration_dev(svg, if_block_anchor);

			if (default_slot) {
				default_slot.m(svg, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*title*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(svg, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*viewBox*/ 2) {
				attr_dev(svg, "viewBox", /*viewBox*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('IconBase', slots, ['default']);
	let { title = null } = $$props;
	let { viewBox } = $$props;
	const writable_props = ['title', 'viewBox'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IconBase> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('viewBox' in $$props) $$invalidate(1, viewBox = $$props.viewBox);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ title, viewBox });

	$$self.$inject_state = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('viewBox' in $$props) $$invalidate(1, viewBox = $$props.viewBox);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, viewBox, $$scope, slots];
}

class IconBase extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { title: 0, viewBox: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBase",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*viewBox*/ ctx[1] === undefined && !('viewBox' in props)) {
			console.warn("<IconBase> was created without expected prop 'viewBox'");
		}
	}

	get title() {
		throw new Error("<IconBase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<IconBase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get viewBox() {
		throw new Error("<IconBase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set viewBox(value) {
		throw new Error("<IconBase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-icons/fa/FaEnvelope.svelte generated by Svelte v3.45.0 */
const file$1 = "node_modules/svelte-icons/fa/FaEnvelope.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z");
			add_location(path, file$1, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FaEnvelope', slots, []);

	$$self.$$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaEnvelope extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaEnvelope",
			options,
			id: create_fragment$1.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaLinkedin.svelte generated by Svelte v3.45.0 */
const file$2 = "node_modules/svelte-icons/fa/FaLinkedin.svelte";

// (4:8) <IconBase viewBox="0 0 448 512" {...$$props}>
function create_default_slot$1(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z");
			add_location(path, file$2, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 448 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 448 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FaLinkedin', slots, []);

	$$self.$$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaLinkedin extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaLinkedin",
			options,
			id: create_fragment$2.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaGithub.svelte generated by Svelte v3.45.0 */
const file$3 = "node_modules/svelte-icons/fa/FaGithub.svelte";

// (4:8) <IconBase viewBox="0 0 496 512" {...$$props}>
function create_default_slot$2(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z");
			add_location(path, file$3, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 496 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 496 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FaGithub', slots, []);

	$$self.$$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaGithub extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaGithub",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src/components/ProjectsImages.svelte generated by Svelte v3.45.0 */
const file$4 = "src/components/ProjectsImages.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (25:0) {#if selectedProject}
function create_if_block$1(ctx) {
	let div6;
	let div5;
	let div1;
	let div0;
	let picture;
	let source0;
	let source0_srcset_value;
	let t0;
	let source1;
	let source1_srcset_value;
	let t1;
	let img;
	let img_src_value;
	let img_alt_value;
	let t2;
	let div4;
	let div2;
	let h3;
	let t3_value = /*selectedProject*/ ctx[1].name + "";
	let t3;
	let t4;
	let div3;
	let t5_value = /*selectedProject*/ ctx[1].blurb[0] + "";
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let t12;
	let t13;
	let t14;
	let t15;
	let div6_intro;
	let mounted;
	let dispose;
	let if_block0 = /*selectedProject*/ ctx[1].blurb[1] && create_if_block_10(ctx);
	let if_block1 = /*selectedProject*/ ctx[1].blurb[2] && create_if_block_9(ctx);
	let if_block2 = /*selectedProject*/ ctx[1].blurb[3] && create_if_block_8(ctx);
	let if_block3 = /*selectedProject*/ ctx[1].blurb[4] && create_if_block_7(ctx);
	let if_block4 = /*selectedProject*/ ctx[1].blurb[5] && create_if_block_6(ctx);
	let if_block5 = /*selectedProject*/ ctx[1].blurb[6] && create_if_block_5(ctx);
	let if_block6 = /*selectedProject*/ ctx[1].blurb[7] && create_if_block_4(ctx);
	let if_block7 = /*selectedProject*/ ctx[1].blurb[8] && create_if_block_3(ctx);
	let if_block8 = /*selectedProject*/ ctx[1].blurb[9] && create_if_block_2(ctx);
	let if_block9 = /*selectedProject*/ ctx[1].blurb[10] && create_if_block_1(ctx);

	const block = {
		c: function create() {
			div6 = element("div");
			div5 = element("div");
			div1 = element("div");
			div0 = element("div");
			picture = element("picture");
			source0 = element("source");
			t0 = space();
			source1 = element("source");
			t1 = space();
			img = element("img");
			t2 = space();
			div4 = element("div");
			div2 = element("div");
			h3 = element("h3");
			t3 = text(t3_value);
			t4 = space();
			div3 = element("div");
			t5 = text(t5_value);
			t6 = space();
			if (if_block0) if_block0.c();
			t7 = space();
			if (if_block1) if_block1.c();
			t8 = space();
			if (if_block2) if_block2.c();
			t9 = space();
			if (if_block3) if_block3.c();
			t10 = space();
			if (if_block4) if_block4.c();
			t11 = space();
			if (if_block5) if_block5.c();
			t12 = space();
			if (if_block6) if_block6.c();
			t13 = space();
			if (if_block7) if_block7.c();
			t14 = space();
			if (if_block8) if_block8.c();
			t15 = space();
			if (if_block9) if_block9.c();
			this.h();
		},
		l: function claim(nodes) {
			div6 = claim_element(nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			div5 = claim_element(div6_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div1 = claim_element(div5_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			picture = claim_element(div0_nodes, "PICTURE", { class: true });
			var picture_nodes = children(picture);
			source0 = claim_element(picture_nodes, "SOURCE", { srcset: true, type: true, class: true });
			t0 = claim_space(picture_nodes);
			source1 = claim_element(picture_nodes, "SOURCE", { srcset: true, type: true, class: true });
			t1 = claim_space(picture_nodes);
			img = claim_element(picture_nodes, "IMG", { src: true, alt: true, class: true });
			picture_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t2 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h3 = claim_element(div2_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t3 = claim_text(h3_nodes, t3_value);
			h3_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t4 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			t5 = claim_text(div3_nodes, t5_value);
			div3_nodes.forEach(detach_dev);
			t6 = claim_space(div4_nodes);
			if (if_block0) if_block0.l(div4_nodes);
			t7 = claim_space(div4_nodes);
			if (if_block1) if_block1.l(div4_nodes);
			t8 = claim_space(div4_nodes);
			if (if_block2) if_block2.l(div4_nodes);
			t9 = claim_space(div4_nodes);
			if (if_block3) if_block3.l(div4_nodes);
			t10 = claim_space(div4_nodes);
			if (if_block4) if_block4.l(div4_nodes);
			t11 = claim_space(div4_nodes);
			if (if_block5) if_block5.l(div4_nodes);
			t12 = claim_space(div4_nodes);
			if (if_block6) if_block6.l(div4_nodes);
			t13 = claim_space(div4_nodes);
			if (if_block7) if_block7.l(div4_nodes);
			t14 = claim_space(div4_nodes);
			if (if_block8) if_block8.l(div4_nodes);
			t15 = claim_space(div4_nodes);
			if (if_block9) if_block9.l(div4_nodes);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			div6_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(source0, "srcset", source0_srcset_value = "" + (`/projects/${/*selectedProject*/ ctx[1].image}` + ".webp"));
			attr_dev(source0, "type", "image/webp");
			attr_dev(source0, "class", "svelte-at2udm");
			add_location(source0, file$4, 33, 12, 2647);
			attr_dev(source1, "srcset", source1_srcset_value = "" + (`/projects/${/*selectedProject*/ ctx[1].image}` + ".png"));
			attr_dev(source1, "type", "image/jpeg");
			attr_dev(source1, "class", "svelte-at2udm");
			add_location(source1, file$4, 36, 12, 2769);
			if (!src_url_equal(img.src, img_src_value = "" + (`/projects/${/*selectedProject*/ ctx[1].image}` + ".webp"))) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = /*selectedProject*/ ctx[1].name);
			attr_dev(img, "class", "svelte-at2udm");
			add_location(img, file$4, 39, 12, 2890);
			attr_dev(picture, "class", "portfolioProjectImage svelte-at2udm");
			add_location(picture, file$4, 32, 10, 2595);
			attr_dev(div0, "class", "modalImageWrapper svelte-at2udm");
			add_location(div0, file$4, 31, 8, 2553);
			attr_dev(div1, "class", "modalHead svelte-at2udm");
			add_location(div1, file$4, 30, 6, 2521);
			attr_dev(h3, "class", "svelte-at2udm");
			add_location(h3, file$4, 46, 13, 3101);
			attr_dev(div2, "class", "svelte-at2udm");
			add_location(div2, file$4, 46, 8, 3096);
			attr_dev(div3, "class", "blurb svelte-at2udm");
			add_location(div3, file$4, 47, 8, 3147);
			attr_dev(div4, "class", "nameAndPosition svelte-at2udm");
			add_location(div4, file$4, 45, 6, 3058);
			attr_dev(div5, "class", "modalContent contentWrapper svelte-at2udm");
			add_location(div5, file$4, 29, 4, 2473);
			attr_dev(div6, "class", "modal svelte-at2udm");
			add_location(div6, file$4, 25, 2, 2374);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div6, anchor);
			append_hydration_dev(div6, div5);
			append_hydration_dev(div5, div1);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, picture);
			append_hydration_dev(picture, source0);
			append_hydration_dev(picture, t0);
			append_hydration_dev(picture, source1);
			append_hydration_dev(picture, t1);
			append_hydration_dev(picture, img);
			append_hydration_dev(div5, t2);
			append_hydration_dev(div5, div4);
			append_hydration_dev(div4, div2);
			append_hydration_dev(div2, h3);
			append_hydration_dev(h3, t3);
			append_hydration_dev(div4, t4);
			append_hydration_dev(div4, div3);
			append_hydration_dev(div3, t5);
			append_hydration_dev(div4, t6);
			if (if_block0) if_block0.m(div4, null);
			append_hydration_dev(div4, t7);
			if (if_block1) if_block1.m(div4, null);
			append_hydration_dev(div4, t8);
			if (if_block2) if_block2.m(div4, null);
			append_hydration_dev(div4, t9);
			if (if_block3) if_block3.m(div4, null);
			append_hydration_dev(div4, t10);
			if (if_block4) if_block4.m(div4, null);
			append_hydration_dev(div4, t11);
			if (if_block5) if_block5.m(div4, null);
			append_hydration_dev(div4, t12);
			if (if_block6) if_block6.m(div4, null);
			append_hydration_dev(div4, t13);
			if (if_block7) if_block7.m(div4, null);
			append_hydration_dev(div4, t14);
			if (if_block8) if_block8.m(div4, null);
			append_hydration_dev(div4, t15);
			if (if_block9) if_block9.m(div4, null);

			if (!mounted) {
				dispose = listen_dev(div6, "click", /*click_handler*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedProject*/ 2 && source0_srcset_value !== (source0_srcset_value = "" + (`/projects/${/*selectedProject*/ ctx[1].image}` + ".webp"))) {
				attr_dev(source0, "srcset", source0_srcset_value);
			}

			if (dirty & /*selectedProject*/ 2 && source1_srcset_value !== (source1_srcset_value = "" + (`/projects/${/*selectedProject*/ ctx[1].image}` + ".png"))) {
				attr_dev(source1, "srcset", source1_srcset_value);
			}

			if (dirty & /*selectedProject*/ 2 && !src_url_equal(img.src, img_src_value = "" + (`/projects/${/*selectedProject*/ ctx[1].image}` + ".webp"))) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*selectedProject*/ 2 && img_alt_value !== (img_alt_value = /*selectedProject*/ ctx[1].name)) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (dirty & /*selectedProject*/ 2 && t3_value !== (t3_value = /*selectedProject*/ ctx[1].name + "")) set_data_dev(t3, t3_value);
			if (dirty & /*selectedProject*/ 2 && t5_value !== (t5_value = /*selectedProject*/ ctx[1].blurb[0] + "")) set_data_dev(t5, t5_value);

			if (/*selectedProject*/ ctx[1].blurb[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_10(ctx);
					if_block0.c();
					if_block0.m(div4, t7);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*selectedProject*/ ctx[1].blurb[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_9(ctx);
					if_block1.c();
					if_block1.m(div4, t8);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*selectedProject*/ ctx[1].blurb[3]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_8(ctx);
					if_block2.c();
					if_block2.m(div4, t9);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*selectedProject*/ ctx[1].blurb[4]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_7(ctx);
					if_block3.c();
					if_block3.m(div4, t10);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*selectedProject*/ ctx[1].blurb[5]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_6(ctx);
					if_block4.c();
					if_block4.m(div4, t11);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*selectedProject*/ ctx[1].blurb[6]) {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_5(ctx);
					if_block5.c();
					if_block5.m(div4, t12);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (/*selectedProject*/ ctx[1].blurb[7]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);
				} else {
					if_block6 = create_if_block_4(ctx);
					if_block6.c();
					if_block6.m(div4, t13);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (/*selectedProject*/ ctx[1].blurb[8]) {
				if (if_block7) {
					if_block7.p(ctx, dirty);
				} else {
					if_block7 = create_if_block_3(ctx);
					if_block7.c();
					if_block7.m(div4, t14);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (/*selectedProject*/ ctx[1].blurb[9]) {
				if (if_block8) {
					if_block8.p(ctx, dirty);
				} else {
					if_block8 = create_if_block_2(ctx);
					if_block8.c();
					if_block8.m(div4, t15);
				}
			} else if (if_block8) {
				if_block8.d(1);
				if_block8 = null;
			}

			if (/*selectedProject*/ ctx[1].blurb[10]) {
				if (if_block9) {
					if_block9.p(ctx, dirty);
				} else {
					if_block9 = create_if_block_1(ctx);
					if_block9.c();
					if_block9.m(div4, null);
				}
			} else if (if_block9) {
				if_block9.d(1);
				if_block9 = null;
			}
		},
		i: function intro(local) {
			if (!div6_intro) {
				add_render_callback(() => {
					div6_intro = create_in_transition(div6, fade, { duration: 100 });
					div6_intro.start();
				});
			}
		},
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div6);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (if_block7) if_block7.d();
			if (if_block8) if_block8.d();
			if (if_block9) if_block9.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(25:0) {#if selectedProject}",
		ctx
	});

	return block;
}

// (49:8) {#if selectedProject.blurb[1]}
function create_if_block_10(ctx) {
	let div;
	let t_value = /*selectedProject*/ ctx[1].blurb[1] + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "blurb svelte-at2udm");
			add_location(div, file$4, 49, 10, 3248);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedProject*/ 2 && t_value !== (t_value = /*selectedProject*/ ctx[1].blurb[1] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(49:8) {#if selectedProject.blurb[1]}",
		ctx
	});

	return block;
}

// (52:8) {#if selectedProject.blurb[2]}
function create_if_block_9(ctx) {
	let div;
	let t_value = /*selectedProject*/ ctx[1].blurb[2] + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "blurb svelte-at2udm");
			add_location(div, file$4, 52, 10, 3363);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedProject*/ 2 && t_value !== (t_value = /*selectedProject*/ ctx[1].blurb[2] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(52:8) {#if selectedProject.blurb[2]}",
		ctx
	});

	return block;
}

// (55:8) {#if selectedProject.blurb[3]}
function create_if_block_8(ctx) {
	let div;
	let t_value = /*selectedProject*/ ctx[1].blurb[3] + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "blurb svelte-at2udm");
			add_location(div, file$4, 55, 10, 3478);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedProject*/ 2 && t_value !== (t_value = /*selectedProject*/ ctx[1].blurb[3] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(55:8) {#if selectedProject.blurb[3]}",
		ctx
	});

	return block;
}

// (58:8) {#if selectedProject.blurb[4]}
function create_if_block_7(ctx) {
	let div;
	let t_value = /*selectedProject*/ ctx[1].blurb[4] + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "blurb svelte-at2udm");
			add_location(div, file$4, 58, 10, 3593);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedProject*/ 2 && t_value !== (t_value = /*selectedProject*/ ctx[1].blurb[4] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(58:8) {#if selectedProject.blurb[4]}",
		ctx
	});

	return block;
}

// (61:8) {#if selectedProject.blurb[5]}
function create_if_block_6(ctx) {
	let div;
	let t_value = /*selectedProject*/ ctx[1].blurb[5] + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "blurb svelte-at2udm");
			add_location(div, file$4, 61, 10, 3708);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedProject*/ 2 && t_value !== (t_value = /*selectedProject*/ ctx[1].blurb[5] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(61:8) {#if selectedProject.blurb[5]}",
		ctx
	});

	return block;
}

// (64:8) {#if selectedProject.blurb[6]}
function create_if_block_5(ctx) {
	let div;
	let t_value = /*selectedProject*/ ctx[1].blurb[6] + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "blurb svelte-at2udm");
			add_location(div, file$4, 64, 10, 3823);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedProject*/ 2 && t_value !== (t_value = /*selectedProject*/ ctx[1].blurb[6] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(64:8) {#if selectedProject.blurb[6]}",
		ctx
	});

	return block;
}

// (67:8) {#if selectedProject.blurb[7]}
function create_if_block_4(ctx) {
	let div;
	let t_value = /*selectedProject*/ ctx[1].blurb[7] + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "blurb svelte-at2udm");
			add_location(div, file$4, 67, 10, 3938);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedProject*/ 2 && t_value !== (t_value = /*selectedProject*/ ctx[1].blurb[7] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(67:8) {#if selectedProject.blurb[7]}",
		ctx
	});

	return block;
}

// (70:8) {#if selectedProject.blurb[8]}
function create_if_block_3(ctx) {
	let div;
	let t_value = /*selectedProject*/ ctx[1].blurb[8] + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "blurb svelte-at2udm");
			add_location(div, file$4, 70, 10, 4053);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedProject*/ 2 && t_value !== (t_value = /*selectedProject*/ ctx[1].blurb[8] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(70:8) {#if selectedProject.blurb[8]}",
		ctx
	});

	return block;
}

// (73:8) {#if selectedProject.blurb[9]}
function create_if_block_2(ctx) {
	let div;
	let t_value = /*selectedProject*/ ctx[1].blurb[9] + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "blurb svelte-at2udm");
			add_location(div, file$4, 73, 10, 4168);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedProject*/ 2 && t_value !== (t_value = /*selectedProject*/ ctx[1].blurb[9] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(73:8) {#if selectedProject.blurb[9]}",
		ctx
	});

	return block;
}

// (76:8) {#if selectedProject.blurb[10]}
function create_if_block_1(ctx) {
	let div;
	let t_value = /*selectedProject*/ ctx[1].blurb[10] + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "blurb svelte-at2udm");
			add_location(div, file$4, 76, 10, 4284);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selectedProject*/ 2 && t_value !== (t_value = /*selectedProject*/ ctx[1].blurb[10] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(76:8) {#if selectedProject.blurb[10]}",
		ctx
	});

	return block;
}

// (85:2) {#each projects as project}
function create_each_block(ctx) {
	let div3;
	let div2;
	let picture;
	let source0;
	let source0_srcset_value;
	let t0;
	let source1;
	let source1_srcset_value;
	let t1;
	let img;
	let img_src_value;
	let img_alt_value;
	let t2;
	let div1;
	let div0;
	let t3_value = /*project*/ ctx[6].name + "";
	let t3;
	let t4;
	let div3_class_value;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[4](/*project*/ ctx[6]);
	}

	const block = {
		c: function create() {
			div3 = element("div");
			div2 = element("div");
			picture = element("picture");
			source0 = element("source");
			t0 = space();
			source1 = element("source");
			t1 = space();
			img = element("img");
			t2 = space();
			div1 = element("div");
			div0 = element("div");
			t3 = text(t3_value);
			t4 = space();
			this.h();
		},
		l: function claim(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			picture = claim_element(div2_nodes, "PICTURE", { class: true });
			var picture_nodes = children(picture);
			source0 = claim_element(picture_nodes, "SOURCE", { srcset: true, type: true, class: true });
			t0 = claim_space(picture_nodes);
			source1 = claim_element(picture_nodes, "SOURCE", { srcset: true, type: true, class: true });
			t1 = claim_space(picture_nodes);
			img = claim_element(picture_nodes, "IMG", { src: true, alt: true, class: true });
			picture_nodes.forEach(detach_dev);
			t2 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t3 = claim_text(div0_nodes, t3_value);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t4 = claim_space(div3_nodes);
			div3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(source0, "srcset", source0_srcset_value = "" + (`/projects/${/*project*/ ctx[6].image}` + ".webp"));
			attr_dev(source0, "type", "image/webp");
			attr_dev(source0, "class", "svelte-at2udm");
			add_location(source0, file$4, 94, 10, 4816);
			attr_dev(source1, "srcset", source1_srcset_value = "" + (`/projects/${/*project*/ ctx[6].image}` + ".png"));
			attr_dev(source1, "type", "image/png");
			attr_dev(source1, "class", "svelte-at2udm");
			add_location(source1, file$4, 95, 10, 4900);
			if (!src_url_equal(img.src, img_src_value = "" + (`/projects/${/*project*/ ctx[6].image}` + ".webp"))) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = /*project*/ ctx[6].name);
			attr_dev(img, "class", "svelte-at2udm");
			add_location(img, file$4, 96, 10, 4982);
			attr_dev(picture, "class", "portfolioProjectImage svelte-at2udm");
			add_location(picture, file$4, 93, 8, 4766);
			attr_dev(div0, "class", "name svelte-at2udm");
			add_location(div0, file$4, 99, 10, 5110);
			attr_dev(div1, "class", "caption svelte-at2udm");
			add_location(div1, file$4, 98, 8, 5078);
			attr_dev(div2, "class", "imageWrapper svelte-at2udm");
			add_location(div2, file$4, 92, 6, 4731);
			attr_dev(div3, "class", div3_class_value = "portfolioProject " + (/*project*/ ctx[6].blurb.join("\n") ? 'clickable' : '') + " svelte-at2udm");
			add_location(div3, file$4, 85, 4, 4538);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div3, anchor);
			append_hydration_dev(div3, div2);
			append_hydration_dev(div2, picture);
			append_hydration_dev(picture, source0);
			append_hydration_dev(picture, t0);
			append_hydration_dev(picture, source1);
			append_hydration_dev(picture, t1);
			append_hydration_dev(picture, img);
			append_hydration_dev(div2, t2);
			append_hydration_dev(div2, div1);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, t3);
			append_hydration_dev(div3, t4);

			if (!mounted) {
				dispose = listen_dev(div3, "click", click_handler_1, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*projects*/ 1 && source0_srcset_value !== (source0_srcset_value = "" + (`/projects/${/*project*/ ctx[6].image}` + ".webp"))) {
				attr_dev(source0, "srcset", source0_srcset_value);
			}

			if (dirty & /*projects*/ 1 && source1_srcset_value !== (source1_srcset_value = "" + (`/projects/${/*project*/ ctx[6].image}` + ".png"))) {
				attr_dev(source1, "srcset", source1_srcset_value);
			}

			if (dirty & /*projects*/ 1 && !src_url_equal(img.src, img_src_value = "" + (`/projects/${/*project*/ ctx[6].image}` + ".webp"))) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*projects*/ 1 && img_alt_value !== (img_alt_value = /*project*/ ctx[6].name)) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (dirty & /*projects*/ 1 && t3_value !== (t3_value = /*project*/ ctx[6].name + "")) set_data_dev(t3, t3_value);

			if (dirty & /*projects*/ 1 && div3_class_value !== (div3_class_value = "portfolioProject " + (/*project*/ ctx[6].blurb.join("\n") ? 'clickable' : '') + " svelte-at2udm")) {
				attr_dev(div3, "class", div3_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(85:2) {#each projects as project}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let t;
	let div;
	let div_class_value;
	let if_block = /*selectedProject*/ ctx[1] && create_if_block$1(ctx);
	let each_value = /*projects*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			t = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "projects " + (/*selectedProject*/ ctx[1] ? 'noScroll' : '') + " svelte-at2udm");
			add_location(div, file$4, 83, 0, 4445);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_hydration_dev(target, t, anchor);
			insert_hydration_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*selectedProject*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*selectedProject*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*projects, showProject*/ 5) {
				each_value = /*projects*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*selectedProject*/ 2 && div_class_value !== (div_class_value = "projects " + (/*selectedProject*/ ctx[1] ? 'noScroll' : '') + " svelte-at2udm")) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			transition_in(if_block);
		},
		o: noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ProjectsImages', slots, []);
	let { projects } = $$props;
	let selectedProject;

	const showProject = project => {
		$$invalidate(1, selectedProject = project);

		if (selectedProject) {
			document.body.style.overflow = "hidden";
		} else {
			document.body.style.overflow = "visible"; //gtag("event", "view_item", { event_label: selectedProject.name });
		}
	};

	const stopPropagation = e => e.stopPropagation();
	const writable_props = ['projects'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ProjectsImages> was created with unknown prop '${key}'`);
	});

	const click_handler = () => showProject(null);

	const click_handler_1 = project => {
		if (project.blurb) {
			showProject(project);
		}
	};

	$$self.$$set = $$props => {
		if ('projects' in $$props) $$invalidate(0, projects = $$props.projects);
	};

	$$self.$capture_state = () => ({
		fade,
		FaEnvelope,
		FaLinkedin,
		FaGithub,
		projects,
		selectedProject,
		showProject,
		stopPropagation
	});

	$$self.$inject_state = $$props => {
		if ('projects' in $$props) $$invalidate(0, projects = $$props.projects);
		if ('selectedProject' in $$props) $$invalidate(1, selectedProject = $$props.selectedProject);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [projects, selectedProject, showProject, click_handler, click_handler_1];
}

class ProjectsImages extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { projects: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ProjectsImages",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*projects*/ ctx[0] === undefined && !('projects' in props)) {
			console.warn("<ProjectsImages> was created without expected prop 'projects'");
		}
	}

	get projects() {
		throw new Error("<ProjectsImages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set projects(value) {
		throw new Error("<ProjectsImages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/projects.svelte generated by Svelte v3.45.0 */
const file$5 = "src/routes/projects.svelte";

// (27:0) <PageHeader>
function create_default_slot$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Design Projects");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Design Projects");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(27:0) <PageHeader>",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let t0;
	let pageheader;
	let t1;
	let div1;
	let div0;
	let t2;
	let t3;
	let projectsimages;
	let current;

	pageheader = new PageHeader({
			props: {
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	projectsimages = new ProjectsImages({
			props: { projects: /*projects*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			create_component(pageheader.$$.fragment);
			t1 = space();
			div1 = element("div");
			div0 = element("div");
			t2 = text("Click on a project to learn more!");
			t3 = space();
			create_component(projectsimages.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all('[data-svelte=\"svelte-11xp49l\"]', document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			claim_component(pageheader.$$.fragment, nodes);
			t1 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", {});
			var div0_nodes = children(div0);
			t2 = claim_text(div0_nodes, "Click on a project to learn more!");
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			claim_component(projectsimages.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "Patrick Singal";
			add_location(div0, file$5, 28, 2, 737);
			attr_dev(div1, "class", "textLine svelte-enifjd");
			add_location(div1, file$5, 27, 0, 712);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t0, anchor);
			mount_component(pageheader, target, anchor);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, t2);
			insert_hydration_dev(target, t3, anchor);
			mount_component(projectsimages, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const pageheader_changes = {};

			if (dirty & /*$$scope*/ 2) {
				pageheader_changes.$$scope = { dirty, ctx };
			}

			pageheader.$set(pageheader_changes);
			const projectsimages_changes = {};
			if (dirty & /*projects*/ 1) projectsimages_changes.projects = /*projects*/ ctx[0];
			projectsimages.$set(projectsimages_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(pageheader.$$.fragment, local);
			transition_in(projectsimages.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(pageheader.$$.fragment, local);
			transition_out(projectsimages.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			destroy_component(pageheader, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div1);
			if (detaching) detach_dev(t3);
			destroy_component(projectsimages, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload() {
	const result = await this.fetch("index.json");
	const { projects } = await result.json();
	return { projects };
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Projects', slots, []);
	let { projects = [] } = $$props;
	const writable_props = ['projects'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Projects> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('projects' in $$props) $$invalidate(0, projects = $$props.projects);
	};

	$$self.$capture_state = () => ({
		preload,
		onMount,
		ProjectsImages,
		PageHeader,
		projects
	});

	$$self.$inject_state = $$props => {
		if ('projects' in $$props) $$invalidate(0, projects = $$props.projects);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [projects];
}

class Projects extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { projects: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Projects",
			options,
			id: create_fragment$5.name
		});
	}

	get projects() {
		throw new Error("<Projects>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set projects(value) {
		throw new Error("<Projects>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Projects;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvamVjdHMuMDY4ZTkyYTUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvdHJhbnNpdGlvbi9pbmRleC5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9mYS9GYUVudmVsb3BlLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvZmEvRmFMaW5rZWRpbi5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL2ZhL0ZhR2l0aHViLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1Byb2plY3RzSW1hZ2VzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvcHJvamVjdHMuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGN1YmljSW5PdXQsIGxpbmVhciwgY3ViaWNPdXQgfSBmcm9tICcuLi9lYXNpbmcvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzX2Z1bmN0aW9uLCBhc3NpZ24gfSBmcm9tICcuLi9pbnRlcm5hbC9pbmRleC5tanMnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbmZ1bmN0aW9uIGJsdXIobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY0luT3V0LCBhbW91bnQgPSA1LCBvcGFjaXR5ID0gMCB9ID0ge30pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCBmID0gc3R5bGUuZmlsdGVyID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLmZpbHRlcjtcbiAgICBjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAoX3QsIHUpID0+IGBvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gKG9kICogdSl9OyBmaWx0ZXI6ICR7Zn0gYmx1cigke3UgKiBhbW91bnR9cHgpO2BcbiAgICB9O1xufVxuZnVuY3Rpb24gZmFkZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGxpbmVhciB9ID0ge30pIHtcbiAgICBjb25zdCBvID0gK2dldENvbXB1dGVkU3R5bGUobm9kZSkub3BhY2l0eTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiB0ID0+IGBvcGFjaXR5OiAke3QgKiBvfWBcbiAgICB9O1xufVxuZnVuY3Rpb24gZmx5KG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNPdXQsIHggPSAwLCB5ID0gMCwgb3BhY2l0eSA9IDAgfSA9IHt9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICBjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7KDEgLSB0KSAqIHh9cHgsICR7KDEgLSB0KSAqIHl9cHgpO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfWBcbiAgICB9O1xufVxuZnVuY3Rpb24gc2xpZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCB9ID0ge30pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IGhlaWdodCA9IHBhcnNlRmxvYXQoc3R5bGUuaGVpZ2h0KTtcbiAgICBjb25zdCBwYWRkaW5nX3RvcCA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1RvcCk7XG4gICAgY29uc3QgcGFkZGluZ19ib3R0b20gPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdCb3R0b20pO1xuICAgIGNvbnN0IG1hcmdpbl90b3AgPSBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpblRvcCk7XG4gICAgY29uc3QgbWFyZ2luX2JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luQm90dG9tKTtcbiAgICBjb25zdCBib3JkZXJfdG9wX3dpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCk7XG4gICAgY29uc3QgYm9yZGVyX2JvdHRvbV93aWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IHQgPT4gJ292ZXJmbG93OiBoaWRkZW47JyArXG4gICAgICAgICAgICBgb3BhY2l0eTogJHtNYXRoLm1pbih0ICogMjAsIDEpICogb3BhY2l0eX07YCArXG4gICAgICAgICAgICBgaGVpZ2h0OiAke3QgKiBoZWlnaHR9cHg7YCArXG4gICAgICAgICAgICBgcGFkZGluZy10b3A6ICR7dCAqIHBhZGRpbmdfdG9wfXB4O2AgK1xuICAgICAgICAgICAgYHBhZGRpbmctYm90dG9tOiAke3QgKiBwYWRkaW5nX2JvdHRvbX1weDtgICtcbiAgICAgICAgICAgIGBtYXJnaW4tdG9wOiAke3QgKiBtYXJnaW5fdG9wfXB4O2AgK1xuICAgICAgICAgICAgYG1hcmdpbi1ib3R0b206ICR7dCAqIG1hcmdpbl9ib3R0b219cHg7YCArXG4gICAgICAgICAgICBgYm9yZGVyLXRvcC13aWR0aDogJHt0ICogYm9yZGVyX3RvcF93aWR0aH1weDtgICtcbiAgICAgICAgICAgIGBib3JkZXItYm90dG9tLXdpZHRoOiAke3QgKiBib3JkZXJfYm90dG9tX3dpZHRofXB4O2BcbiAgICB9O1xufVxuZnVuY3Rpb24gc2NhbGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgc3RhcnQgPSAwLCBvcGFjaXR5ID0gMCB9ID0ge30pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgIGNvbnN0IHNkID0gMSAtIHN0YXJ0O1xuICAgIGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IChfdCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gc2NhbGUoJHsxIC0gKHNkICogdSl9KTtcblx0XHRcdG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSAob2QgKiB1KX1cblx0XHRgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRyYXcobm9kZSwgeyBkZWxheSA9IDAsIHNwZWVkLCBkdXJhdGlvbiwgZWFzaW5nID0gY3ViaWNJbk91dCB9ID0ge30pIHtcbiAgICBsZXQgbGVuID0gbm9kZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoc3R5bGUuc3Ryb2tlTGluZWNhcCAhPT0gJ2J1dHQnKSB7XG4gICAgICAgIGxlbiArPSBwYXJzZUludChzdHlsZS5zdHJva2VXaWR0aCk7XG4gICAgfVxuICAgIGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzcGVlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IDgwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gbGVuIC8gc3BlZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24obGVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKHQsIHUpID0+IGBzdHJva2UtZGFzaGFycmF5OiAke3QgKiBsZW59ICR7dSAqIGxlbn1gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyb3NzZmFkZShfYSkge1xuICAgIHZhciB7IGZhbGxiYWNrIH0gPSBfYSwgZGVmYXVsdHMgPSBfX3Jlc3QoX2EsIFtcImZhbGxiYWNrXCJdKTtcbiAgICBjb25zdCB0b19yZWNlaXZlID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHRvX3NlbmQgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gY3Jvc3NmYWRlKGZyb20sIG5vZGUsIHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSBkID0+IE1hdGguc3FydChkKSAqIDMwLCBlYXNpbmcgPSBjdWJpY091dCB9ID0gYXNzaWduKGFzc2lnbih7fSwgZGVmYXVsdHMpLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGR4ID0gZnJvbS5sZWZ0IC0gdG8ubGVmdDtcbiAgICAgICAgY29uc3QgZHkgPSBmcm9tLnRvcCAtIHRvLnRvcDtcbiAgICAgICAgY29uc3QgZHcgPSBmcm9tLndpZHRoIC8gdG8ud2lkdGg7XG4gICAgICAgIGNvbnN0IGRoID0gZnJvbS5oZWlnaHQgLyB0by5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgZHVyYXRpb246IGlzX2Z1bmN0aW9uKGR1cmF0aW9uKSA/IGR1cmF0aW9uKGQpIDogZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmcsXG4gICAgICAgICAgICBjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHRcdG9wYWNpdHk6ICR7dCAqIG9wYWNpdHl9O1xuXHRcdFx0XHR0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDtcblx0XHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7dSAqIGR4fXB4LCR7dSAqIGR5fXB4KSBzY2FsZSgke3QgKyAoMSAtIHQpICogZHd9LCAke3QgKyAoMSAtIHQpICogZGh9KTtcblx0XHRcdGBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbihpdGVtcywgY291bnRlcnBhcnRzLCBpbnRybykge1xuICAgICAgICByZXR1cm4gKG5vZGUsIHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaXRlbXMuc2V0KHBhcmFtcy5rZXksIHtcbiAgICAgICAgICAgICAgICByZWN0OiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJwYXJ0cy5oYXMocGFyYW1zLmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZWN0IH0gPSBjb3VudGVycGFydHMuZ2V0KHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVycGFydHMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Jvc3NmYWRlKHJlY3QsIG5vZGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGRpc2FwcGVhcmluZyBhbHRvZ2V0aGVyXG4gICAgICAgICAgICAgICAgLy8gKGkuZS4gd2Fzbid0IGNsYWltZWQgYnkgdGhlIG90aGVyIGxpc3QpXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHN1cHBseSBhbiBvdXRyb1xuICAgICAgICAgICAgICAgIGl0ZW1zLmRlbGV0ZShwYXJhbXMua2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsbGJhY2sgJiYgZmFsbGJhY2sobm9kZSwgcGFyYW1zLCBpbnRybyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICB0cmFuc2l0aW9uKHRvX3NlbmQsIHRvX3JlY2VpdmUsIGZhbHNlKSxcbiAgICAgICAgdHJhbnNpdGlvbih0b19yZWNlaXZlLCB0b19zZW5kLCB0cnVlKVxuICAgIF07XG59XG5cbmV4cG9ydCB7IGJsdXIsIGNyb3NzZmFkZSwgZHJhdywgZmFkZSwgZmx5LCBzY2FsZSwgc2xpZGUgfTtcbiIsIjxzY3JpcHQ+XG4gIGV4cG9ydCBsZXQgdGl0bGUgPSBudWxsO1xuICBleHBvcnQgbGV0IHZpZXdCb3g7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBzdmcge1xuICAgIHN0cm9rZTogY3VycmVudENvbG9yO1xuICAgIGZpbGw6IGN1cnJlbnRDb2xvcjtcbiAgICBzdHJva2Utd2lkdGg6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiBhdXRvO1xuICAgIG1heC1oZWlnaHQ6IDEwMCU7XG4gIH0gIFxuPC9zdHlsZT5cblxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIge3ZpZXdCb3h9PlxuICB7I2lmIHRpdGxlfVxuICAgIDx0aXRsZT57dGl0bGV9PC90aXRsZT5cbiAgey9pZn1cbiAgPHNsb3QgLz5cbjwvc3ZnPlxuIiwiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk01MDIuMyAxOTAuOGMzLjktMy4xIDkuNy0uMiA5LjcgNC43VjQwMGMwIDI2LjUtMjEuNSA0OC00OCA0OEg0OGMtMjYuNSAwLTQ4LTIxLjUtNDgtNDhWMTk1LjZjMC01IDUuNy03LjggOS43LTQuNyAyMi40IDE3LjQgNTIuMSAzOS41IDE1NC4xIDExMy42IDIxLjEgMTUuNCA1Ni43IDQ3LjggOTIuMiA0Ny42IDM1LjcuMyA3Mi0zMi44IDkyLjMtNDcuNiAxMDItNzQuMSAxMzEuNi05Ni4zIDE1NC0xMTMuN3pNMjU2IDMyMGMyMy4yLjQgNTYuNi0yOS4yIDczLjQtNDEuNCAxMzIuNy05Ni4zIDE0Mi44LTEwNC43IDE3My40LTEyOC43IDUuOC00LjUgOS4yLTExLjUgOS4yLTE4Ljl2LTE5YzAtMjYuNS0yMS41LTQ4LTQ4LTQ4SDQ4QzIxLjUgNjQgMCA4NS41IDAgMTEydjE5YzAgNy40IDMuNCAxNC4zIDkuMiAxOC45IDMwLjYgMjMuOSA0MC43IDMyLjQgMTczLjQgMTI4LjcgMTYuOCAxMi4yIDUwLjIgNDEuOCA3My40IDQxLjR6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCA0NDggNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNNDE2IDMySDMxLjlDMTQuMyAzMiAwIDQ2LjUgMCA2NC4zdjM4My40QzAgNDY1LjUgMTQuMyA0ODAgMzEuOSA0ODBINDE2YzE3LjYgMCAzMi0xNC41IDMyLTMyLjNWNjQuM2MwLTE3LjgtMTQuNC0zMi4zLTMyLTMyLjN6TTEzNS40IDQxNkg2OVYyMDIuMmg2Ni41VjQxNnptLTMzLjItMjQzYy0yMS4zIDAtMzguNS0xNy4zLTM4LjUtMzguNVM4MC45IDk2IDEwMi4yIDk2YzIxLjIgMCAzOC41IDE3LjMgMzguNSAzOC41IDAgMjEuMy0xNy4yIDM4LjUtMzguNSAzOC41em0yODIuMSAyNDNoLTY2LjRWMzEyYzAtMjQuOC0uNS01Ni43LTM0LjUtNTYuNy0zNC42IDAtMzkuOSAyNy0zOS45IDU0LjlWNDE2aC02Ni40VjIwMi4yaDYzLjd2MjkuMmguOWM4LjktMTYuOCAzMC42LTM0LjUgNjIuOS0zNC41IDY3LjIgMCA3OS43IDQ0LjMgNzkuNyAxMDEuOVY0MTZ6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCA0OTYgNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTY1LjkgMzk3LjRjMCAyLTIuMyAzLjYtNS4yIDMuNi0zLjMuMy01LjYtMS4zLTUuNi0zLjYgMC0yIDIuMy0zLjYgNS4yLTMuNiAzLS4zIDUuNiAxLjMgNS42IDMuNnptLTMxLjEtNC41Yy0uNyAyIDEuMyA0LjMgNC4zIDQuOSAyLjYgMSA1LjYgMCA2LjItMnMtMS4zLTQuMy00LjMtNS4yYy0yLjYtLjctNS41LjMtNi4yIDIuM3ptNDQuMi0xLjdjLTIuOS43LTQuOSAyLjYtNC42IDQuOS4zIDIgMi45IDMuMyA1LjkgMi42IDIuOS0uNyA0LjktMi42IDQuNi00LjYtLjMtMS45LTMtMy4yLTUuOS0yLjl6TTI0NC44IDhDMTA2LjEgOCAwIDExMy4zIDAgMjUyYzAgMTEwLjkgNjkuOCAyMDUuOCAxNjkuNSAyMzkuMiAxMi44IDIuMyAxNy4zLTUuNiAxNy4zLTEyLjEgMC02LjItLjMtNDAuNC0uMy02MS40IDAgMC03MCAxNS04NC43LTI5LjggMCAwLTExLjQtMjkuMS0yNy44LTM2LjYgMCAwLTIyLjktMTUuNyAxLjYtMTUuNCAwIDAgMjQuOSAyIDM4LjYgMjUuOCAyMS45IDM4LjYgNTguNiAyNy41IDcyLjkgMjAuOSAyLjMtMTYgOC44LTI3LjEgMTYtMzMuNy01NS45LTYuMi0xMTIuMy0xNC4zLTExMi4zLTExMC41IDAtMjcuNSA3LjYtNDEuMyAyMy42LTU4LjktMi42LTYuNS0xMS4xLTMzLjMgMi42LTY3LjkgMjAuOS02LjUgNjkgMjcgNjkgMjcgMjAtNS42IDQxLjUtOC41IDYyLjgtOC41czQyLjggMi45IDYyLjggOC41YzAgMCA0OC4xLTMzLjYgNjktMjcgMTMuNyAzNC43IDUuMiA2MS40IDIuNiA2Ny45IDE2IDE3LjcgMjUuOCAzMS41IDI1LjggNTguOSAwIDk2LjUtNTguOSAxMDQuMi0xMTQuOCAxMTAuNSA5LjIgNy45IDE3IDIyLjkgMTcgNDYuNCAwIDMzLjctLjMgNzUuNC0uMyA4My42IDAgNi41IDQuNiAxNC40IDE3LjMgMTIuMUM0MjguMiA0NTcuOCA0OTYgMzYyLjkgNDk2IDI1MiA0OTYgMTEzLjMgMzgzLjUgOCAyNDQuOCA4ek05Ny4yIDM1Mi45Yy0xLjMgMS0xIDMuMy43IDUuMiAxLjYgMS42IDMuOSAyLjMgNS4yIDEgMS4zLTEgMS0zLjMtLjctNS4yLTEuNi0xLjYtMy45LTIuMy01LjItMXptLTEwLjgtOC4xYy0uNyAxLjMuMyAyLjkgMi4zIDMuOSAxLjYgMSAzLjYuNyA0LjMtLjcuNy0xLjMtLjMtMi45LTIuMy0zLjktMi0uNi0zLjYtLjMtNC4zLjd6bTMyLjQgMzUuNmMtMS42IDEuMy0xIDQuMyAxLjMgNi4yIDIuMyAyLjMgNS4yIDIuNiA2LjUgMSAxLjMtMS4zLjctNC4zLTEuMy02LjItMi4yLTIuMy01LjItMi42LTYuNS0xem0tMTEuNC0xNC43Yy0xLjYgMS0xLjYgMy42IDAgNS45IDEuNiAyLjMgNC4zIDMuMyA1LjYgMi4zIDEuNi0xLjMgMS42LTMuOSAwLTYuMi0xLjQtMi4zLTQtMy4zLTUuNi0yelwiIC8+XG4gICAgICAgIDwvSWNvbkJhc2U+XG4gICAgICAiLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBmYWRlIH0gZnJvbSBcInN2ZWx0ZS90cmFuc2l0aW9uXCI7XG4gIGltcG9ydCBGYUVudmVsb3BlIGZyb20gXCJzdmVsdGUtaWNvbnMvZmEvRmFFbnZlbG9wZS5zdmVsdGVcIjtcbiAgaW1wb3J0IEZhTGlua2VkaW4gZnJvbSBcInN2ZWx0ZS1pY29ucy9mYS9GYUxpbmtlZGluLnN2ZWx0ZVwiO1xuICBpbXBvcnQgRmFHaXRodWIgZnJvbSBcInN2ZWx0ZS1pY29ucy9mYS9GYUdpdGh1Yi5zdmVsdGVcIjtcbiAgZXhwb3J0IGxldCBwcm9qZWN0cztcblxuICBsZXQgc2VsZWN0ZWRQcm9qZWN0O1xuXG4gIGNvbnN0IHNob3dQcm9qZWN0ID0gcHJvamVjdCA9PiB7XG4gICAgc2VsZWN0ZWRQcm9qZWN0ID0gcHJvamVjdDtcbiAgICBpZiAoc2VsZWN0ZWRQcm9qZWN0KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgIC8vZ3RhZyhcImV2ZW50XCIsIFwidmlld19pdGVtXCIsIHsgZXZlbnRfbGFiZWw6IHNlbGVjdGVkUHJvamVjdC5uYW1lIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJ2aXNpYmxlXCI7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHN0b3BQcm9wYWdhdGlvbiA9IGUgPT4gZS5zdG9wUHJvcGFnYXRpb24oKTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIC5pbWFnZVdyYXBwZXIge1xuICAgIGhlaWdodDogMzMwcHg7XG4gICAgd2lkdGg6IDMzMHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgbWFyZ2luLWJvdHRvbTogMC43cmVtO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgfVxuXG4gIC5wb3J0Zm9saW9Qcm9qZWN0LmNsaWNrYWJsZSB7XG4gICAgY3Vyc29yOiBncmFiYmluZztcbiAgfVxuICAuaW1hZ2VXcmFwcGVyIC5wb3J0Zm9saW9Qcm9qZWN0SW1hZ2UgPiAqIHtcbiAgICAvKiBwb3NpdGlvbjogYWJzb2x1dGU7ICovXG4gICAgaGVpZ2h0OiAzMzBweDtcbiAgICB3aWR0aDogYXV0bztcbiAgICBtYXJnaW4tcmlnaHQ6IGF1dG87XG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gICAgLyogdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIHJpZ2h0OiAwOyAqL1xuICB9XG5cbiAgLmltYWdlV3JhcHBlciBkaXYuY2FwdGlvbiB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgcGFkZGluZzogMC41cmVtO1xuICAgIGZvbnQtc2l6ZTogMC45cmVtO1xuICAgIGxpbmUtaGVpZ2h0OiAwLjlyZW07XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBoZWlnaHQ6IDNyZW07XG4gICAgYm90dG9tOiAtM3JlbTtcbiAgICB0cmFuc2l0aW9uOiBib3R0b20gMC4zcyBlYXNlO1xuICB9XG5cbiAgLmltYWdlV3JhcHBlcjpob3ZlciBkaXYuY2FwdGlvbiB7XG4gICAgYm90dG9tOiAwO1xuICB9XG5cbiAgQG1lZGlhIChob3Zlcjogbm9uZSkge1xuICAgIC5pbWFnZVdyYXBwZXIgZGl2LmNhcHRpb24ge1xuICAgICAgYm90dG9tOiAwICFpbXBvcnRhbnQ7XG4gICAgfVxuICB9XG5cbiAgZGl2LnByb2plY3RzIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIG1hcmdpbjogM3JlbSBhdXRvIDA7XG4gICAgbWF4LXdpZHRoOiBjYWxjKDM3MHB4ICogNCk7XG4gIH1cbiAgZGl2LnBvcnRmb2xpb1Byb2plY3Qge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDAgMC4ycmVtO1xuICB9XG4gIGRpdi5uYW1lIHtcbiAgICBmb250LXdlaWdodDogNjAwO1xuICAgIGNvbG9yOiB2YXIoLS1kYXJrR3JleSk7XG4gICAgZm9udC1zaXplOiAwLjlyZW07XG4gICAgbGluZS1oZWlnaHQ6IDAuOXJlbTtcbiAgfVxuXG4gIC8qIGRpdi5wb3NpdGlvbiB7XG4gICAgY29sb3I6IHZhcigtLWRhcmtHcmV5KTtcbiAgICBmb250LXdlaWdodDogNTAwO1xuICAgIGZvbnQtc3R5bGU6IGl0YWxpYztcbiAgICBmb250LXNpemU6IDAuOXJlbTtcbiAgICBsaW5lLWhlaWdodDogMnJlbTtcbn0gKi9cblxuICBkaXYubW9kYWwge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45Myk7XG4gICAgei1pbmRleDogNDg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgfVxuXG4gIC5tb2RhbCBkaXYubW9kYWxDb250ZW50IHtcbiAgICBtaW4td2lkdGg6IDcwJTtcbiAgICBtaW4taGVpZ2h0OiA2MCU7XG4gICAgbWFyZ2luOiBhdXRvO1xuICAgIHBhZGRpbmc6IDFyZW07XG4gIH1cblxuICAubW9kYWwgZGl2Lm1vZGFsSGVhZCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG5cbiAgLm1vZGFsIGRpdi5uYW1lQW5kUG9zaXRpb24gPiAqIHtcbiAgICBwYWRkaW5nOiAwO1xuICAgIG1hcmdpbjogMDtcbiAgICB0ZXh0LXRyYW5zZm9ybTogdW5zZXQ7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgfVxuXG4gIGRpdi5tb2RhbEhlYWQgPiBkaXYubW9kYWxJbWFnZVdyYXBwZXIge1xuICAgIGhlaWdodDogNzN2aDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICAgIG1hcmdpbi1yaWdodDogYXV0bztcbiAgfVxuXG4gIC5tb2RhbCBkaXYubW9kYWxJbWFnZVdyYXBwZXIgcGljdHVyZSA+ICoge1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuXG4gIC8qIC5tb2RhbCBkaXYubW9kYWxQb3NpdGlvbiB7XG4gICAgZm9udC1zaXplOiAwLjlyZW07XG4gIH0gKi9cblxuICAubW9kYWwgZGl2LmJsdXJiIHtcbiAgICBwYWRkaW5nLXRvcDogMC41cmVtO1xuICAgIHBhZGRpbmctYm90dG9tOiAwLjVyZW07XG4gICAgZm9udC1zaXplOiAwLjlyZW07XG4gICAgbGluZS1oZWlnaHQ6IDEuMXJlbTtcbiAgICBmb250LXdlaWdodDogMzAwO1xuICAgIHRleHQtYWxpZ246IGp1c3RpZnk7XG4gICAgdGV4dC1qdXN0aWZ5OiBpbnRlci13b3JkO1xuICB9XG5cbiAgLyoubW9kYWwgcC5ibHVyYiB7XG4gICAgbWFyZ2luOiAxLjVyZW0gMDtcbiAgICBsaW5lLWhlaWdodDogMS44cmVtO1xuICB9Ki9cblxuICAubW9kYWwgaDMge1xuICAgIGZvbnQtc2l6ZTogMS41cmVtO1xuICAgIGxpbmUtaGVpZ2h0OjEuNXJlbTtcbiAgICBwYWRkaW5nLXRvcDogMXJlbTtcbiAgICBwYWRkaW5nLWJvdHRvbTogMC41cmVtO1xuICB9XG48L3N0eWxlPlxuXG57I2lmIHNlbGVjdGVkUHJvamVjdH1cbiAgPGRpdlxuICAgIGNsYXNzPVwibW9kYWxcIlxuICAgIGluOmZhZGU9e3sgZHVyYXRpb246IDEwMCB9fVxuICAgIG9uOmNsaWNrPXsoKSA9PiBzaG93UHJvamVjdChudWxsKX0+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsQ29udGVudCBjb250ZW50V3JhcHBlclwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsSGVhZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWxJbWFnZVdyYXBwZXJcIj5cbiAgICAgICAgICA8cGljdHVyZSBjbGFzcz1cInBvcnRmb2xpb1Byb2plY3RJbWFnZVwiPlxuICAgICAgICAgICAgPHNvdXJjZVxuICAgICAgICAgICAgICBzcmNzZXQ9XCJ7YC9wcm9qZWN0cy8ke3NlbGVjdGVkUHJvamVjdC5pbWFnZX1gfS53ZWJwXCJcbiAgICAgICAgICAgICAgdHlwZT1cImltYWdlL3dlYnBcIiAvPlxuICAgICAgICAgICAgPHNvdXJjZVxuICAgICAgICAgICAgICBzcmNzZXQ9XCJ7YC9wcm9qZWN0cy8ke3NlbGVjdGVkUHJvamVjdC5pbWFnZX1gfS5wbmdcIlxuICAgICAgICAgICAgICB0eXBlPVwiaW1hZ2UvanBlZ1wiIC8+XG4gICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgIHNyYz1cIntgL3Byb2plY3RzLyR7c2VsZWN0ZWRQcm9qZWN0LmltYWdlfWB9LndlYnBcIlxuICAgICAgICAgICAgICBhbHQ9e3NlbGVjdGVkUHJvamVjdC5uYW1lfSAvPlxuICAgICAgICAgIDwvcGljdHVyZT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJuYW1lQW5kUG9zaXRpb25cIj5cbiAgICAgICAgPGRpdj48aDM+e3NlbGVjdGVkUHJvamVjdC5uYW1lfTwvaDM+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJibHVyYlwiPntzZWxlY3RlZFByb2plY3QuYmx1cmJbMF19PC9kaXY+XG4gICAgICAgIHsjaWYgc2VsZWN0ZWRQcm9qZWN0LmJsdXJiWzFdfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJibHVyYlwiPntzZWxlY3RlZFByb2plY3QuYmx1cmJbMV19PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgc2VsZWN0ZWRQcm9qZWN0LmJsdXJiWzJdfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJibHVyYlwiPntzZWxlY3RlZFByb2plY3QuYmx1cmJbMl19PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgc2VsZWN0ZWRQcm9qZWN0LmJsdXJiWzNdfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJibHVyYlwiPntzZWxlY3RlZFByb2plY3QuYmx1cmJbM119PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgc2VsZWN0ZWRQcm9qZWN0LmJsdXJiWzRdfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJibHVyYlwiPntzZWxlY3RlZFByb2plY3QuYmx1cmJbNF19PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgc2VsZWN0ZWRQcm9qZWN0LmJsdXJiWzVdfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJibHVyYlwiPntzZWxlY3RlZFByb2plY3QuYmx1cmJbNV19PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgc2VsZWN0ZWRQcm9qZWN0LmJsdXJiWzZdfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJibHVyYlwiPntzZWxlY3RlZFByb2plY3QuYmx1cmJbNl19PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgc2VsZWN0ZWRQcm9qZWN0LmJsdXJiWzddfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJibHVyYlwiPntzZWxlY3RlZFByb2plY3QuYmx1cmJbN119PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgc2VsZWN0ZWRQcm9qZWN0LmJsdXJiWzhdfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJibHVyYlwiPntzZWxlY3RlZFByb2plY3QuYmx1cmJbOF19PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgc2VsZWN0ZWRQcm9qZWN0LmJsdXJiWzldfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJibHVyYlwiPntzZWxlY3RlZFByb2plY3QuYmx1cmJbOV19PC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgc2VsZWN0ZWRQcm9qZWN0LmJsdXJiWzEwXX1cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiYmx1cmJcIj57c2VsZWN0ZWRQcm9qZWN0LmJsdXJiWzEwXX08L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICAgICAgPCEtLSA8cD57c2VsZWN0ZWRQcm9qZWN0LmJsdXJiLmpvaW4oKX08L3A+IC0tPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2Plxuey9pZn1cbjxkaXYgY2xhc3M9XCJwcm9qZWN0cyB7c2VsZWN0ZWRQcm9qZWN0ID8gJ25vU2Nyb2xsJyA6ICcnfVwiPlxuICB7I2VhY2ggcHJvamVjdHMgYXMgcHJvamVjdH1cbiAgICA8ZGl2XG4gICAgICBjbGFzcz1cInBvcnRmb2xpb1Byb2plY3Qge3Byb2plY3QuYmx1cmIuam9pbihcIlxcblwiKSA/ICdjbGlja2FibGUnIDogJyd9XCJcbiAgICAgIG9uOmNsaWNrPXsoKSA9PiB7XG4gICAgICAgIGlmIChwcm9qZWN0LmJsdXJiKSB7XG4gICAgICAgICAgc2hvd1Byb2plY3QocHJvamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH19PlxuICAgICAgPGRpdiBjbGFzcz1cImltYWdlV3JhcHBlclwiPlxuICAgICAgICA8cGljdHVyZSBjbGFzcz1cInBvcnRmb2xpb1Byb2plY3RJbWFnZVwiPlxuICAgICAgICAgIDxzb3VyY2Ugc3Jjc2V0PVwie2AvcHJvamVjdHMvJHtwcm9qZWN0LmltYWdlfWB9LndlYnBcIiB0eXBlPVwiaW1hZ2Uvd2VicFwiIC8+XG4gICAgICAgICAgPHNvdXJjZSBzcmNzZXQ9XCJ7YC9wcm9qZWN0cy8ke3Byb2plY3QuaW1hZ2V9YH0ucG5nXCIgdHlwZT1cImltYWdlL3BuZ1wiIC8+XG4gICAgICAgICAgPGltZyBzcmM9XCJ7YC9wcm9qZWN0cy8ke3Byb2plY3QuaW1hZ2V9YH0ud2VicFwiIGFsdD17cHJvamVjdC5uYW1lfSAvPlxuICAgICAgICA8L3BpY3R1cmU+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjYXB0aW9uXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5hbWVcIj57cHJvamVjdC5uYW1lfTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICB7L2VhY2h9XG48L2Rpdj5cbiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxuICBleHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoKFwiaW5kZXguanNvblwiKTtcbiAgICBjb25zdCB7IHByb2plY3RzIH0gPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9qZWN0c1xuICAgIH07XG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIGRpdi50ZXh0TGluZSB7XG4gICAgbWFyZ2luLXRvcDogMC41cmVtO1xuICAgIG1hcmdpbi1ib3R0b206IDByZW07XG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xuICAgIGZvbnQtc2l6ZTogMC40cmVtO1xuICAgIGZvbnQtc3R5bGU6IGl0YWxpYztcbiAgfVxuPC9zdHlsZT5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IFByb2plY3RzSW1hZ2VzIGZyb20gXCIuLi9jb21wb25lbnRzL1Byb2plY3RzSW1hZ2VzLnN2ZWx0ZVwiO1xuICBpbXBvcnQgUGFnZUhlYWRlciBmcm9tIFwiLi4vY29tcG9uZW50cy9QYWdlSGVhZGVyLnN2ZWx0ZVwiO1xuXG4vLyAgIG9uTW91bnQoYXN5bmMgKCkgPT4ge1xuLy8gICAgIGd0YWcoXCJjb25maWdcIiwgXCJVQS05MzU0OTIzNS02XCIsIHsgcGFnZV9wYXRoOiBcIi9wcm9qZWN0c1wiIH0pO1xuLy8gICB9KTtcbiAgZXhwb3J0IGxldCBwcm9qZWN0cyA9IFtdO1xuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6aGVhZD5cbiAgPHRpdGxlPlBhdHJpY2sgU2luZ2FsPC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG48UGFnZUhlYWRlcj5EZXNpZ24gUHJvamVjdHM8L1BhZ2VIZWFkZXI+XG48ZGl2IGNsYXNzPVwidGV4dExpbmVcIj5cbiAgPGRpdj5DbGljayBvbiBhIHByb2plY3QgdG8gbGVhcm4gbW9yZSE8L2Rpdj5cbjwvZGl2PlxuPFByb2plY3RzSW1hZ2VzIHtwcm9qZWN0c30gLz5cbiJdLCJuYW1lcyI6WyJsaW5lYXIiXSwibWFwcGluZ3MiOiI7OztBQTBDQSxTQUFTLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLFFBQVEsR0FBRyxHQUFHLEVBQUUsTUFBTSxHQUFHQSxRQUFNLEVBQUUsR0FBRyxFQUFFLEVBQUU7QUFDekUsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQztBQUM5QyxJQUFJLE9BQU87QUFDWCxRQUFRLEtBQUs7QUFDYixRQUFRLFFBQVE7QUFDaEIsUUFBUSxNQUFNO0FBQ2QsUUFBUSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNyQyxLQUFLLENBQUM7QUFDTjs7Ozs7Ozs7Ozs7Ozs7c0JDekNZLEdBQUs7Ozs7OzsyQ0FBTCxHQUFLOzs7Ozs7OztHQUFiLG9CQUFzQjs7OztzREFBZCxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQURWLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FEWixvQkFLTTs7Ozs7Ozs7Ozs7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QWUsSUFBQyxLQUFLLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7OzsyQkFHdkIsR0FBZSxJQUFDLEtBQUssQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7OzJCQUd2QixHQUFlLElBQUMsS0FBSyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7MkJBR3ZCLEdBQWUsSUFBQyxLQUFLLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7OzsyQkFHdkIsR0FBZSxJQUFDLEtBQUssQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7OzJCQUd2QixHQUFlLElBQUMsS0FBSyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7MkJBR3ZCLEdBQWUsSUFBQyxLQUFLLENBQUMsRUFBRTs7Ozs7Ozs7Ozs7Ozs7OztxREFoRHRCLFFBQVEsRUFBRSxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQXNCRSxHQUFlLElBQUMsS0FBSyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQUEzQyxvQkFBbUQ7Ozs7bUZBQS9CLEdBQWUsSUFBQyxLQUFLLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQUd2QixHQUFlLElBQUMsS0FBSyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQUEzQyxvQkFBbUQ7Ozs7bUZBQS9CLEdBQWUsSUFBQyxLQUFLLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQUd2QixHQUFlLElBQUMsS0FBSyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQUEzQyxvQkFBbUQ7Ozs7bUZBQS9CLEdBQWUsSUFBQyxLQUFLLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQUd2QixHQUFlLElBQUMsS0FBSyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQUEzQyxvQkFBbUQ7Ozs7bUZBQS9CLEdBQWUsSUFBQyxLQUFLLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQUd2QixHQUFlLElBQUMsS0FBSyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQUEzQyxv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
